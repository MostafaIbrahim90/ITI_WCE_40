
RTOS_test_EX1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000019d4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  000019d4  00001a68  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e5  00800068  00800068  00001a70  2**0
                  ALLOC
  3 .stab         00000888  00000000  00000000  00001a70  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  000022f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  000024a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000021e7  00000000  00000000  000025e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009fe  00000000  00000000  000047cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ba4  00000000  00000000  000051cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000708  00000000  00000000  00005d74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e49  00000000  00000000  0000647c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001e55  00000000  00000000  000072c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  0000911a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 be 04 	jmp	0x97c	; 0x97c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ed       	ldi	r30, 0xD4	; 212
      68:	f9 e1       	ldi	r31, 0x19	; 25
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 34       	cpi	r26, 0x4D	; 77
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 c3 07 	call	0xf86	; 0xf86 <main>
      8a:	0c 94 e8 0c 	jmp	0x19d0	; 0x19d0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	1f 93       	push	r17
      a2:	cf 93       	push	r28
      a4:	df 93       	push	r29
      a6:	6c 01       	movw	r12, r24
      a8:	e6 2e       	mov	r14, r22
      aa:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
      ac:	8a e1       	ldi	r24, 0x1A	; 26
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
      b4:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
      b6:	00 97       	sbiw	r24, 0x00	; 0
      b8:	09 f4       	brne	.+2      	; 0xbc <xCoRoutineCreate+0x2a>
      ba:	62 c0       	rjmp	.+196    	; 0x180 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      bc:	80 91 68 00 	lds	r24, 0x0068
      c0:	90 91 69 00 	lds	r25, 0x0069
      c4:	00 97       	sbiw	r24, 0x00	; 0
      c6:	39 f5       	brne	.+78     	; 0x116 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
      c8:	10 93 69 00 	sts	0x0069, r17
      cc:	00 93 68 00 	sts	0x0068, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      d0:	cb e6       	ldi	r28, 0x6B	; 107
      d2:	d0 e0       	ldi	r29, 0x00	; 0
      d4:	ce 01       	movw	r24, r28
      d6:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
      da:	ce 01       	movw	r24, r28
      dc:	09 96       	adiw	r24, 0x09	; 9
      de:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
      e2:	cd e7       	ldi	r28, 0x7D	; 125
      e4:	d0 e0       	ldi	r29, 0x00	; 0
      e6:	ce 01       	movw	r24, r28
      e8:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
      ec:	0f 2e       	mov	r0, r31
      ee:	f6 e8       	ldi	r31, 0x86	; 134
      f0:	af 2e       	mov	r10, r31
      f2:	f0 e0       	ldi	r31, 0x00	; 0
      f4:	bf 2e       	mov	r11, r31
      f6:	f0 2d       	mov	r31, r0
      f8:	c5 01       	movw	r24, r10
      fa:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
      fe:	8f e8       	ldi	r24, 0x8F	; 143
     100:	90 e0       	ldi	r25, 0x00	; 0
     102:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     106:	d0 93 99 00 	sts	0x0099, r29
     10a:	c0 93 98 00 	sts	0x0098, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     10e:	b0 92 9b 00 	sts	0x009B, r11
     112:	a0 92 9a 00 	sts	0x009A, r10
     116:	ce 2d       	mov	r28, r14
     118:	e1 10       	cpse	r14, r1
     11a:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     11c:	f8 01       	movw	r30, r16
     11e:	11 8e       	std	Z+25, r1	; 0x19
     120:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     122:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     124:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     126:	c1 92       	st	Z+, r12
     128:	d1 92       	st	Z+, r13
     12a:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     12c:	cf 01       	movw	r24, r30
     12e:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     132:	c8 01       	movw	r24, r16
     134:	0c 96       	adiw	r24, 0x0c	; 12
     136:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     13a:	f8 01       	movw	r30, r16
     13c:	11 87       	std	Z+9, r17	; 0x09
     13e:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     140:	13 8b       	std	Z+19, r17	; 0x13
     142:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     144:	83 e0       	ldi	r24, 0x03	; 3
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	8c 1b       	sub	r24, r28
     14a:	91 09       	sbc	r25, r1
     14c:	95 87       	std	Z+13, r25	; 0x0d
     14e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     150:	86 89       	ldd	r24, Z+22	; 0x16
     152:	90 91 6a 00 	lds	r25, 0x006A
     156:	98 17       	cp	r25, r24
     158:	10 f4       	brcc	.+4      	; 0x15e <xCoRoutineCreate+0xcc>
     15a:	80 93 6a 00 	sts	0x006A, r24
     15e:	90 e0       	ldi	r25, 0x00	; 0
     160:	9c 01       	movw	r18, r24
     162:	22 0f       	add	r18, r18
     164:	33 1f       	adc	r19, r19
     166:	22 0f       	add	r18, r18
     168:	33 1f       	adc	r19, r19
     16a:	22 0f       	add	r18, r18
     16c:	33 1f       	adc	r19, r19
     16e:	82 0f       	add	r24, r18
     170:	93 1f       	adc	r25, r19
     172:	85 59       	subi	r24, 0x95	; 149
     174:	9f 4f       	sbci	r25, 0xFF	; 255
     176:	b7 01       	movw	r22, r14
     178:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

		xReturn = pdPASS;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	01 c0       	rjmp	.+2      	; 0x182 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     180:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     182:	df 91       	pop	r29
     184:	cf 91       	pop	r28
     186:	1f 91       	pop	r17
     188:	0f 91       	pop	r16
     18a:	ff 90       	pop	r15
     18c:	ef 90       	pop	r14
     18e:	df 90       	pop	r13
     190:	cf 90       	pop	r12
     192:	bf 90       	pop	r11
     194:	af 90       	pop	r10
     196:	08 95       	ret

00000198 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1a2:	c0 91 9c 00 	lds	r28, 0x009C
     1a6:	d0 91 9d 00 	lds	r29, 0x009D
     1aa:	c8 0f       	add	r28, r24
     1ac:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1ae:	80 91 68 00 	lds	r24, 0x0068
     1b2:	90 91 69 00 	lds	r25, 0x0069
     1b6:	02 96       	adiw	r24, 0x02	; 2
     1b8:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1bc:	e0 91 68 00 	lds	r30, 0x0068
     1c0:	f0 91 69 00 	lds	r31, 0x0069
     1c4:	d3 83       	std	Z+3, r29	; 0x03
     1c6:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     1c8:	80 91 9c 00 	lds	r24, 0x009C
     1cc:	90 91 9d 00 	lds	r25, 0x009D
     1d0:	c8 17       	cp	r28, r24
     1d2:	d9 07       	cpc	r29, r25
     1d4:	50 f4       	brcc	.+20     	; 0x1ea <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1d6:	bf 01       	movw	r22, r30
     1d8:	6e 5f       	subi	r22, 0xFE	; 254
     1da:	7f 4f       	sbci	r23, 0xFF	; 255
     1dc:	80 91 9a 00 	lds	r24, 0x009A
     1e0:	90 91 9b 00 	lds	r25, 0x009B
     1e4:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
     1e8:	09 c0       	rjmp	.+18     	; 0x1fc <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1ea:	bf 01       	movw	r22, r30
     1ec:	6e 5f       	subi	r22, 0xFE	; 254
     1ee:	7f 4f       	sbci	r23, 0xFF	; 255
     1f0:	80 91 98 00 	lds	r24, 0x0098
     1f4:	90 91 99 00 	lds	r25, 0x0099
     1f8:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
	}

	if( pxEventList )
     1fc:	01 15       	cp	r16, r1
     1fe:	11 05       	cpc	r17, r1
     200:	49 f0       	breq	.+18     	; 0x214 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     202:	60 91 68 00 	lds	r22, 0x0068
     206:	70 91 69 00 	lds	r23, 0x0069
     20a:	64 5f       	subi	r22, 0xF4	; 244
     20c:	7f 4f       	sbci	r23, 0xFF	; 255
     20e:	c8 01       	movw	r24, r16
     210:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
	}
}
     214:	df 91       	pop	r29
     216:	cf 91       	pop	r28
     218:	1f 91       	pop	r17
     21a:	0f 91       	pop	r16
     21c:	08 95       	ret

0000021e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     21e:	cf 92       	push	r12
     220:	df 92       	push	r13
     222:	ef 92       	push	r14
     224:	ff 92       	push	r15
     226:	0f 93       	push	r16
     228:	1f 93       	push	r17
     22a:	cf 93       	push	r28
     22c:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     22e:	80 91 8f 00 	lds	r24, 0x008F
     232:	88 23       	and	r24, r24
     234:	b9 f1       	breq	.+110    	; 0x2a4 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     236:	0f 2e       	mov	r0, r31
     238:	f4 e9       	ldi	r31, 0x94	; 148
     23a:	ef 2e       	mov	r14, r31
     23c:	f0 e0       	ldi	r31, 0x00	; 0
     23e:	ff 2e       	mov	r15, r31
     240:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     242:	0f 2e       	mov	r0, r31
     244:	ff e8       	ldi	r31, 0x8F	; 143
     246:	cf 2e       	mov	r12, r31
     248:	f0 e0       	ldi	r31, 0x00	; 0
     24a:	df 2e       	mov	r13, r31
     24c:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     24e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     250:	d7 01       	movw	r26, r14
     252:	ed 91       	ld	r30, X+
     254:	fc 91       	ld	r31, X
     256:	c6 81       	ldd	r28, Z+6	; 0x06
     258:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     25a:	ce 01       	movw	r24, r28
     25c:	0c 96       	adiw	r24, 0x0c	; 12
     25e:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
		}
		portENABLE_INTERRUPTS();
     262:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     264:	8e 01       	movw	r16, r28
     266:	0e 5f       	subi	r16, 0xFE	; 254
     268:	1f 4f       	sbci	r17, 0xFF	; 255
     26a:	c8 01       	movw	r24, r16
     26c:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     270:	8e 89       	ldd	r24, Y+22	; 0x16
     272:	90 91 6a 00 	lds	r25, 0x006A
     276:	98 17       	cp	r25, r24
     278:	10 f4       	brcc	.+4      	; 0x27e <vCoRoutineSchedule+0x60>
     27a:	80 93 6a 00 	sts	0x006A, r24
     27e:	90 e0       	ldi	r25, 0x00	; 0
     280:	9c 01       	movw	r18, r24
     282:	22 0f       	add	r18, r18
     284:	33 1f       	adc	r19, r19
     286:	22 0f       	add	r18, r18
     288:	33 1f       	adc	r19, r19
     28a:	22 0f       	add	r18, r18
     28c:	33 1f       	adc	r19, r19
     28e:	82 0f       	add	r24, r18
     290:	93 1f       	adc	r25, r19
     292:	85 59       	subi	r24, 0x95	; 149
     294:	9f 4f       	sbci	r25, 0xFF	; 255
     296:	b8 01       	movw	r22, r16
     298:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     29c:	f6 01       	movw	r30, r12
     29e:	80 81       	ld	r24, Z
     2a0:	88 23       	and	r24, r24
     2a2:	a9 f6       	brne	.-86     	; 0x24e <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     2a4:	0e 94 bc 09 	call	0x1378	; 0x1378 <xTaskGetTickCount>
     2a8:	20 91 9e 00 	lds	r18, 0x009E
     2ac:	30 91 9f 00 	lds	r19, 0x009F
     2b0:	82 1b       	sub	r24, r18
     2b2:	93 0b       	sbc	r25, r19
     2b4:	90 93 a1 00 	sts	0x00A1, r25
     2b8:	80 93 a0 00 	sts	0x00A0, r24
     2bc:	74 c0       	rjmp	.+232    	; 0x3a6 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     2be:	20 91 9c 00 	lds	r18, 0x009C
     2c2:	30 91 9d 00 	lds	r19, 0x009D
     2c6:	2f 5f       	subi	r18, 0xFF	; 255
     2c8:	3f 4f       	sbci	r19, 0xFF	; 255
     2ca:	30 93 9d 00 	sts	0x009D, r19
     2ce:	20 93 9c 00 	sts	0x009C, r18
		xPassedTicks--;
     2d2:	01 97       	sbiw	r24, 0x01	; 1
     2d4:	90 93 a1 00 	sts	0x00A1, r25
     2d8:	80 93 a0 00 	sts	0x00A0, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     2dc:	21 15       	cp	r18, r1
     2de:	31 05       	cpc	r19, r1
     2e0:	81 f4       	brne	.+32     	; 0x302 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     2e2:	80 91 98 00 	lds	r24, 0x0098
     2e6:	90 91 99 00 	lds	r25, 0x0099
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     2ea:	20 91 9a 00 	lds	r18, 0x009A
     2ee:	30 91 9b 00 	lds	r19, 0x009B
     2f2:	30 93 99 00 	sts	0x0099, r19
     2f6:	20 93 98 00 	sts	0x0098, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     2fa:	90 93 9b 00 	sts	0x009B, r25
     2fe:	80 93 9a 00 	sts	0x009A, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     302:	e0 91 98 00 	lds	r30, 0x0098
     306:	f0 91 99 00 	lds	r31, 0x0099
     30a:	80 81       	ld	r24, Z
     30c:	88 23       	and	r24, r24
     30e:	09 f4       	brne	.+2      	; 0x312 <vCoRoutineSchedule+0xf4>
     310:	4a c0       	rjmp	.+148    	; 0x3a6 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     312:	05 80       	ldd	r0, Z+5	; 0x05
     314:	f6 81       	ldd	r31, Z+6	; 0x06
     316:	e0 2d       	mov	r30, r0
     318:	c6 81       	ldd	r28, Z+6	; 0x06
     31a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     31c:	2a 81       	ldd	r18, Y+2	; 0x02
     31e:	3b 81       	ldd	r19, Y+3	; 0x03
     320:	80 91 9c 00 	lds	r24, 0x009C
     324:	90 91 9d 00 	lds	r25, 0x009D
     328:	82 17       	cp	r24, r18
     32a:	93 07       	cpc	r25, r19
     32c:	78 f4       	brcc	.+30     	; 0x34c <vCoRoutineSchedule+0x12e>
     32e:	3b c0       	rjmp	.+118    	; 0x3a6 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     330:	05 80       	ldd	r0, Z+5	; 0x05
     332:	f6 81       	ldd	r31, Z+6	; 0x06
     334:	e0 2d       	mov	r30, r0
     336:	c6 81       	ldd	r28, Z+6	; 0x06
     338:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     33a:	2a 81       	ldd	r18, Y+2	; 0x02
     33c:	3b 81       	ldd	r19, Y+3	; 0x03
     33e:	80 91 9c 00 	lds	r24, 0x009C
     342:	90 91 9d 00 	lds	r25, 0x009D
     346:	82 17       	cp	r24, r18
     348:	93 07       	cpc	r25, r19
     34a:	68 f1       	brcs	.+90     	; 0x3a6 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     34c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     34e:	8e 01       	movw	r16, r28
     350:	0e 5f       	subi	r16, 0xFE	; 254
     352:	1f 4f       	sbci	r17, 0xFF	; 255
     354:	c8 01       	movw	r24, r16
     356:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     35a:	8c 89       	ldd	r24, Y+20	; 0x14
     35c:	9d 89       	ldd	r25, Y+21	; 0x15
     35e:	00 97       	sbiw	r24, 0x00	; 0
     360:	21 f0       	breq	.+8      	; 0x36a <vCoRoutineSchedule+0x14c>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     362:	ce 01       	movw	r24, r28
     364:	0c 96       	adiw	r24, 0x0c	; 12
     366:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     36a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     36c:	8e 89       	ldd	r24, Y+22	; 0x16
     36e:	90 91 6a 00 	lds	r25, 0x006A
     372:	98 17       	cp	r25, r24
     374:	10 f4       	brcc	.+4      	; 0x37a <vCoRoutineSchedule+0x15c>
     376:	80 93 6a 00 	sts	0x006A, r24
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	9c 01       	movw	r18, r24
     37e:	22 0f       	add	r18, r18
     380:	33 1f       	adc	r19, r19
     382:	22 0f       	add	r18, r18
     384:	33 1f       	adc	r19, r19
     386:	22 0f       	add	r18, r18
     388:	33 1f       	adc	r19, r19
     38a:	82 0f       	add	r24, r18
     38c:	93 1f       	adc	r25, r19
     38e:	85 59       	subi	r24, 0x95	; 149
     390:	9f 4f       	sbci	r25, 0xFF	; 255
     392:	b8 01       	movw	r22, r16
     394:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     398:	e0 91 98 00 	lds	r30, 0x0098
     39c:	f0 91 99 00 	lds	r31, 0x0099
     3a0:	80 81       	ld	r24, Z
     3a2:	88 23       	and	r24, r24
     3a4:	29 f6       	brne	.-118    	; 0x330 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     3a6:	80 91 a0 00 	lds	r24, 0x00A0
     3aa:	90 91 a1 00 	lds	r25, 0x00A1
     3ae:	00 97       	sbiw	r24, 0x00	; 0
     3b0:	09 f0       	breq	.+2      	; 0x3b4 <vCoRoutineSchedule+0x196>
     3b2:	85 cf       	rjmp	.-246    	; 0x2be <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     3b4:	80 91 9c 00 	lds	r24, 0x009C
     3b8:	90 91 9d 00 	lds	r25, 0x009D
     3bc:	90 93 9f 00 	sts	0x009F, r25
     3c0:	80 93 9e 00 	sts	0x009E, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3c4:	20 91 6a 00 	lds	r18, 0x006A
     3c8:	82 2f       	mov	r24, r18
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	fc 01       	movw	r30, r24
     3ce:	ee 0f       	add	r30, r30
     3d0:	ff 1f       	adc	r31, r31
     3d2:	ee 0f       	add	r30, r30
     3d4:	ff 1f       	adc	r31, r31
     3d6:	ee 0f       	add	r30, r30
     3d8:	ff 1f       	adc	r31, r31
     3da:	e8 0f       	add	r30, r24
     3dc:	f9 1f       	adc	r31, r25
     3de:	e5 59       	subi	r30, 0x95	; 149
     3e0:	ff 4f       	sbci	r31, 0xFF	; 255
     3e2:	30 81       	ld	r19, Z
     3e4:	33 23       	and	r19, r19
     3e6:	d9 f4       	brne	.+54     	; 0x41e <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3e8:	22 23       	and	r18, r18
     3ea:	31 f4       	brne	.+12     	; 0x3f8 <vCoRoutineSchedule+0x1da>
     3ec:	47 c0       	rjmp	.+142    	; 0x47c <vCoRoutineSchedule+0x25e>
     3ee:	22 23       	and	r18, r18
     3f0:	19 f4       	brne	.+6      	; 0x3f8 <vCoRoutineSchedule+0x1da>
     3f2:	20 93 6a 00 	sts	0x006A, r18
     3f6:	42 c0       	rjmp	.+132    	; 0x47c <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     3f8:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3fa:	82 2f       	mov	r24, r18
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	fc 01       	movw	r30, r24
     400:	ee 0f       	add	r30, r30
     402:	ff 1f       	adc	r31, r31
     404:	ee 0f       	add	r30, r30
     406:	ff 1f       	adc	r31, r31
     408:	ee 0f       	add	r30, r30
     40a:	ff 1f       	adc	r31, r31
     40c:	e8 0f       	add	r30, r24
     40e:	f9 1f       	adc	r31, r25
     410:	e5 59       	subi	r30, 0x95	; 149
     412:	ff 4f       	sbci	r31, 0xFF	; 255
     414:	30 81       	ld	r19, Z
     416:	33 23       	and	r19, r19
     418:	51 f3       	breq	.-44     	; 0x3ee <vCoRoutineSchedule+0x1d0>
     41a:	20 93 6a 00 	sts	0x006A, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     41e:	fc 01       	movw	r30, r24
     420:	ee 0f       	add	r30, r30
     422:	ff 1f       	adc	r31, r31
     424:	ee 0f       	add	r30, r30
     426:	ff 1f       	adc	r31, r31
     428:	ee 0f       	add	r30, r30
     42a:	ff 1f       	adc	r31, r31
     42c:	8e 0f       	add	r24, r30
     42e:	9f 1f       	adc	r25, r31
     430:	fc 01       	movw	r30, r24
     432:	e5 59       	subi	r30, 0x95	; 149
     434:	ff 4f       	sbci	r31, 0xFF	; 255
     436:	a1 81       	ldd	r26, Z+1	; 0x01
     438:	b2 81       	ldd	r27, Z+2	; 0x02
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	0d 90       	ld	r0, X+
     43e:	bc 91       	ld	r27, X
     440:	a0 2d       	mov	r26, r0
     442:	b2 83       	std	Z+2, r27	; 0x02
     444:	a1 83       	std	Z+1, r26	; 0x01
     446:	cf 01       	movw	r24, r30
     448:	03 96       	adiw	r24, 0x03	; 3
     44a:	a8 17       	cp	r26, r24
     44c:	b9 07       	cpc	r27, r25
     44e:	31 f4       	brne	.+12     	; 0x45c <vCoRoutineSchedule+0x23e>
     450:	12 96       	adiw	r26, 0x02	; 2
     452:	8d 91       	ld	r24, X+
     454:	9c 91       	ld	r25, X
     456:	13 97       	sbiw	r26, 0x03	; 3
     458:	92 83       	std	Z+2, r25	; 0x02
     45a:	81 83       	std	Z+1, r24	; 0x01
     45c:	01 80       	ldd	r0, Z+1	; 0x01
     45e:	f2 81       	ldd	r31, Z+2	; 0x02
     460:	e0 2d       	mov	r30, r0
     462:	a6 81       	ldd	r26, Z+6	; 0x06
     464:	b7 81       	ldd	r27, Z+7	; 0x07
     466:	b0 93 69 00 	sts	0x0069, r27
     46a:	a0 93 68 00 	sts	0x0068, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     46e:	ed 91       	ld	r30, X+
     470:	fc 91       	ld	r31, X
     472:	11 97       	sbiw	r26, 0x01	; 1
     474:	cd 01       	movw	r24, r26
     476:	57 96       	adiw	r26, 0x17	; 23
     478:	6c 91       	ld	r22, X
     47a:	09 95       	icall

	return;
}
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	1f 91       	pop	r17
     482:	0f 91       	pop	r16
     484:	ff 90       	pop	r15
     486:	ef 90       	pop	r14
     488:	df 90       	pop	r13
     48a:	cf 90       	pop	r12
     48c:	08 95       	ret

0000048e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     48e:	0f 93       	push	r16
     490:	1f 93       	push	r17
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     496:	dc 01       	movw	r26, r24
     498:	15 96       	adiw	r26, 0x05	; 5
     49a:	ed 91       	ld	r30, X+
     49c:	fc 91       	ld	r31, X
     49e:	16 97       	sbiw	r26, 0x06	; 6
     4a0:	06 81       	ldd	r16, Z+6	; 0x06
     4a2:	17 81       	ldd	r17, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4a4:	e8 01       	movw	r28, r16
     4a6:	2c 96       	adiw	r28, 0x0c	; 12
     4a8:	ce 01       	movw	r24, r28
     4aa:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4ae:	8f e8       	ldi	r24, 0x8F	; 143
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	be 01       	movw	r22, r28
     4b4:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4b8:	e0 91 68 00 	lds	r30, 0x0068
     4bc:	f0 91 69 00 	lds	r31, 0x0069
	{
		xReturn = pdTRUE;
     4c0:	81 e0       	ldi	r24, 0x01	; 1
     4c2:	d8 01       	movw	r26, r16
     4c4:	56 96       	adiw	r26, 0x16	; 22
     4c6:	2c 91       	ld	r18, X
     4c8:	56 97       	sbiw	r26, 0x16	; 22
     4ca:	96 89       	ldd	r25, Z+22	; 0x16
     4cc:	29 17       	cp	r18, r25
     4ce:	08 f4       	brcc	.+2      	; 0x4d2 <xCoRoutineRemoveFromEventList+0x44>
     4d0:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     4d2:	df 91       	pop	r29
     4d4:	cf 91       	pop	r28
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	08 95       	ret

000004dc <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4dc:	0f 93       	push	r16
     4de:	1f 93       	push	r17
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4e6:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     4ea:	00 91 a2 00 	lds	r16, 0x00A2
     4ee:	10 91 a3 00 	lds	r17, 0x00A3
     4f2:	c0 0f       	add	r28, r16
     4f4:	d1 1f       	adc	r29, r17
     4f6:	82 e0       	ldi	r24, 0x02	; 2
     4f8:	c8 35       	cpi	r28, 0x58	; 88
     4fa:	d8 07       	cpc	r29, r24
     4fc:	50 f4       	brcc	.+20     	; 0x512 <pvPortMalloc+0x36>
     4fe:	0c 17       	cp	r16, r28
     500:	1d 07       	cpc	r17, r29
     502:	50 f4       	brcc	.+20     	; 0x518 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     504:	0c 55       	subi	r16, 0x5C	; 92
     506:	1f 4f       	sbci	r17, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     508:	d0 93 a3 00 	sts	0x00A3, r29
     50c:	c0 93 a2 00 	sts	0x00A2, r28
     510:	05 c0       	rjmp	.+10     	; 0x51c <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     512:	00 e0       	ldi	r16, 0x00	; 0
     514:	10 e0       	ldi	r17, 0x00	; 0
     516:	02 c0       	rjmp	.+4      	; 0x51c <pvPortMalloc+0x40>
     518:	00 e0       	ldi	r16, 0x00	; 0
     51a:	10 e0       	ldi	r17, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     51c:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     520:	80 2f       	mov	r24, r16
     522:	91 2f       	mov	r25, r17
     524:	df 91       	pop	r29
     526:	cf 91       	pop	r28
     528:	1f 91       	pop	r17
     52a:	0f 91       	pop	r16
     52c:	08 95       	ret

0000052e <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     52e:	08 95       	ret

00000530 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     530:	10 92 a3 00 	sts	0x00A3, r1
     534:	10 92 a2 00 	sts	0x00A2, r1
}
     538:	08 95       	ret

0000053a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     53a:	20 91 a2 00 	lds	r18, 0x00A2
     53e:	30 91 a3 00 	lds	r19, 0x00A3
     542:	88 e5       	ldi	r24, 0x58	; 88
     544:	92 e0       	ldi	r25, 0x02	; 2
     546:	82 1b       	sub	r24, r18
     548:	93 0b       	sbc	r25, r19
}
     54a:	08 95       	ret

0000054c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     54c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     54e:	03 96       	adiw	r24, 0x03	; 3
     550:	92 83       	std	Z+2, r25	; 0x02
     552:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     554:	2f ef       	ldi	r18, 0xFF	; 255
     556:	3f ef       	ldi	r19, 0xFF	; 255
     558:	34 83       	std	Z+4, r19	; 0x04
     55a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     55c:	96 83       	std	Z+6, r25	; 0x06
     55e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     560:	90 87       	std	Z+8, r25	; 0x08
     562:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     564:	10 82       	st	Z, r1
}
     566:	08 95       	ret

00000568 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     568:	fc 01       	movw	r30, r24
     56a:	11 86       	std	Z+9, r1	; 0x09
     56c:	10 86       	std	Z+8, r1	; 0x08
}
     56e:	08 95       	ret

00000570 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
     574:	ec 01       	movw	r28, r24
     576:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     578:	89 81       	ldd	r24, Y+1	; 0x01
     57a:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     57c:	dc 01       	movw	r26, r24
     57e:	12 96       	adiw	r26, 0x02	; 2
     580:	2d 91       	ld	r18, X+
     582:	3c 91       	ld	r19, X
     584:	13 97       	sbiw	r26, 0x03	; 3
     586:	33 83       	std	Z+3, r19	; 0x03
     588:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     58a:	29 81       	ldd	r18, Y+1	; 0x01
     58c:	3a 81       	ldd	r19, Y+2	; 0x02
     58e:	35 83       	std	Z+5, r19	; 0x05
     590:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     592:	12 96       	adiw	r26, 0x02	; 2
     594:	2d 91       	ld	r18, X+
     596:	3c 91       	ld	r19, X
     598:	13 97       	sbiw	r26, 0x03	; 3
     59a:	d9 01       	movw	r26, r18
     59c:	15 96       	adiw	r26, 0x05	; 5
     59e:	7c 93       	st	X, r23
     5a0:	6e 93       	st	-X, r22
     5a2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     5a4:	dc 01       	movw	r26, r24
     5a6:	13 96       	adiw	r26, 0x03	; 3
     5a8:	7c 93       	st	X, r23
     5aa:	6e 93       	st	-X, r22
     5ac:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     5ae:	7a 83       	std	Y+2, r23	; 0x02
     5b0:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5b2:	d1 87       	std	Z+9, r29	; 0x09
     5b4:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     5b6:	88 81       	ld	r24, Y
     5b8:	8f 5f       	subi	r24, 0xFF	; 255
     5ba:	88 83       	st	Y, r24
}
     5bc:	df 91       	pop	r29
     5be:	cf 91       	pop	r28
     5c0:	08 95       	ret

000005c2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	ac 01       	movw	r20, r24
     5c8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     5ca:	28 81       	ld	r18, Y
     5cc:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5ce:	8f ef       	ldi	r24, 0xFF	; 255
     5d0:	2f 3f       	cpi	r18, 0xFF	; 255
     5d2:	38 07       	cpc	r19, r24
     5d4:	21 f4       	brne	.+8      	; 0x5de <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5d6:	fa 01       	movw	r30, r20
     5d8:	a7 81       	ldd	r26, Z+7	; 0x07
     5da:	b0 85       	ldd	r27, Z+8	; 0x08
     5dc:	18 c0       	rjmp	.+48     	; 0x60e <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     5de:	da 01       	movw	r26, r20
     5e0:	13 96       	adiw	r26, 0x03	; 3
     5e2:	fa 01       	movw	r30, r20
     5e4:	85 81       	ldd	r24, Z+5	; 0x05
     5e6:	96 81       	ldd	r25, Z+6	; 0x06
     5e8:	fc 01       	movw	r30, r24
     5ea:	80 81       	ld	r24, Z
     5ec:	91 81       	ldd	r25, Z+1	; 0x01
     5ee:	28 17       	cp	r18, r24
     5f0:	39 07       	cpc	r19, r25
     5f2:	68 f0       	brcs	.+26     	; 0x60e <vListInsert+0x4c>
     5f4:	12 96       	adiw	r26, 0x02	; 2
     5f6:	0d 90       	ld	r0, X+
     5f8:	bc 91       	ld	r27, X
     5fa:	a0 2d       	mov	r26, r0
     5fc:	12 96       	adiw	r26, 0x02	; 2
     5fe:	ed 91       	ld	r30, X+
     600:	fc 91       	ld	r31, X
     602:	13 97       	sbiw	r26, 0x03	; 3
     604:	80 81       	ld	r24, Z
     606:	91 81       	ldd	r25, Z+1	; 0x01
     608:	28 17       	cp	r18, r24
     60a:	39 07       	cpc	r19, r25
     60c:	98 f7       	brcc	.-26     	; 0x5f4 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     60e:	12 96       	adiw	r26, 0x02	; 2
     610:	ed 91       	ld	r30, X+
     612:	fc 91       	ld	r31, X
     614:	13 97       	sbiw	r26, 0x03	; 3
     616:	fb 83       	std	Y+3, r31	; 0x03
     618:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     61a:	d5 83       	std	Z+5, r29	; 0x05
     61c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     61e:	bd 83       	std	Y+5, r27	; 0x05
     620:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     622:	13 96       	adiw	r26, 0x03	; 3
     624:	dc 93       	st	X, r29
     626:	ce 93       	st	-X, r28
     628:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62a:	59 87       	std	Y+9, r21	; 0x09
     62c:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     62e:	fa 01       	movw	r30, r20
     630:	80 81       	ld	r24, Z
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	80 83       	st	Z, r24
}
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     63c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     63e:	a2 81       	ldd	r26, Z+2	; 0x02
     640:	b3 81       	ldd	r27, Z+3	; 0x03
     642:	84 81       	ldd	r24, Z+4	; 0x04
     644:	95 81       	ldd	r25, Z+5	; 0x05
     646:	15 96       	adiw	r26, 0x05	; 5
     648:	9c 93       	st	X, r25
     64a:	8e 93       	st	-X, r24
     64c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     64e:	a4 81       	ldd	r26, Z+4	; 0x04
     650:	b5 81       	ldd	r27, Z+5	; 0x05
     652:	82 81       	ldd	r24, Z+2	; 0x02
     654:	93 81       	ldd	r25, Z+3	; 0x03
     656:	13 96       	adiw	r26, 0x03	; 3
     658:	9c 93       	st	X, r25
     65a:	8e 93       	st	-X, r24
     65c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     65e:	a0 85       	ldd	r26, Z+8	; 0x08
     660:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     662:	11 96       	adiw	r26, 0x01	; 1
     664:	8d 91       	ld	r24, X+
     666:	9c 91       	ld	r25, X
     668:	12 97       	sbiw	r26, 0x02	; 2
     66a:	8e 17       	cp	r24, r30
     66c:	9f 07       	cpc	r25, r31
     66e:	31 f4       	brne	.+12     	; 0x67c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     670:	84 81       	ldd	r24, Z+4	; 0x04
     672:	95 81       	ldd	r25, Z+5	; 0x05
     674:	12 96       	adiw	r26, 0x02	; 2
     676:	9c 93       	st	X, r25
     678:	8e 93       	st	-X, r24
     67a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     67c:	11 86       	std	Z+9, r1	; 0x09
     67e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     680:	8c 91       	ld	r24, X
     682:	81 50       	subi	r24, 0x01	; 1
     684:	8c 93       	st	X, r24
}
     686:	08 95       	ret

00000688 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     688:	21 e1       	ldi	r18, 0x11	; 17
     68a:	fc 01       	movw	r30, r24
     68c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     68e:	31 97       	sbiw	r30, 0x01	; 1
     690:	32 e2       	ldi	r19, 0x22	; 34
     692:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     694:	fc 01       	movw	r30, r24
     696:	32 97       	sbiw	r30, 0x02	; 2
     698:	a3 e3       	ldi	r26, 0x33	; 51
     69a:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     69c:	fc 01       	movw	r30, r24
     69e:	33 97       	sbiw	r30, 0x03	; 3
     6a0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     6a2:	fc 01       	movw	r30, r24
     6a4:	34 97       	sbiw	r30, 0x04	; 4
     6a6:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     6a8:	fc 01       	movw	r30, r24
     6aa:	35 97       	sbiw	r30, 0x05	; 5
     6ac:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     6ae:	fc 01       	movw	r30, r24
     6b0:	36 97       	sbiw	r30, 0x06	; 6
     6b2:	60 e8       	ldi	r22, 0x80	; 128
     6b4:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     6b6:	fc 01       	movw	r30, r24
     6b8:	37 97       	sbiw	r30, 0x07	; 7
     6ba:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     6bc:	fc 01       	movw	r30, r24
     6be:	38 97       	sbiw	r30, 0x08	; 8
     6c0:	62 e0       	ldi	r22, 0x02	; 2
     6c2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     6c4:	fc 01       	movw	r30, r24
     6c6:	39 97       	sbiw	r30, 0x09	; 9
     6c8:	63 e0       	ldi	r22, 0x03	; 3
     6ca:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     6cc:	fc 01       	movw	r30, r24
     6ce:	3a 97       	sbiw	r30, 0x0a	; 10
     6d0:	64 e0       	ldi	r22, 0x04	; 4
     6d2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     6d4:	fc 01       	movw	r30, r24
     6d6:	3b 97       	sbiw	r30, 0x0b	; 11
     6d8:	65 e0       	ldi	r22, 0x05	; 5
     6da:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     6dc:	fc 01       	movw	r30, r24
     6de:	3c 97       	sbiw	r30, 0x0c	; 12
     6e0:	66 e0       	ldi	r22, 0x06	; 6
     6e2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     6e4:	fc 01       	movw	r30, r24
     6e6:	3d 97       	sbiw	r30, 0x0d	; 13
     6e8:	67 e0       	ldi	r22, 0x07	; 7
     6ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     6ec:	fc 01       	movw	r30, r24
     6ee:	3e 97       	sbiw	r30, 0x0e	; 14
     6f0:	68 e0       	ldi	r22, 0x08	; 8
     6f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     6f4:	fc 01       	movw	r30, r24
     6f6:	3f 97       	sbiw	r30, 0x0f	; 15
     6f8:	69 e0       	ldi	r22, 0x09	; 9
     6fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     6fc:	fc 01       	movw	r30, r24
     6fe:	70 97       	sbiw	r30, 0x10	; 16
     700:	60 e1       	ldi	r22, 0x10	; 16
     702:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     704:	fc 01       	movw	r30, r24
     706:	71 97       	sbiw	r30, 0x11	; 17
     708:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     70a:	fc 01       	movw	r30, r24
     70c:	72 97       	sbiw	r30, 0x12	; 18
     70e:	22 e1       	ldi	r18, 0x12	; 18
     710:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     712:	fc 01       	movw	r30, r24
     714:	73 97       	sbiw	r30, 0x13	; 19
     716:	23 e1       	ldi	r18, 0x13	; 19
     718:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     71a:	fc 01       	movw	r30, r24
     71c:	74 97       	sbiw	r30, 0x14	; 20
     71e:	24 e1       	ldi	r18, 0x14	; 20
     720:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     722:	fc 01       	movw	r30, r24
     724:	75 97       	sbiw	r30, 0x15	; 21
     726:	25 e1       	ldi	r18, 0x15	; 21
     728:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     72a:	fc 01       	movw	r30, r24
     72c:	76 97       	sbiw	r30, 0x16	; 22
     72e:	26 e1       	ldi	r18, 0x16	; 22
     730:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     732:	fc 01       	movw	r30, r24
     734:	77 97       	sbiw	r30, 0x17	; 23
     736:	27 e1       	ldi	r18, 0x17	; 23
     738:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     73a:	fc 01       	movw	r30, r24
     73c:	78 97       	sbiw	r30, 0x18	; 24
     73e:	28 e1       	ldi	r18, 0x18	; 24
     740:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     742:	fc 01       	movw	r30, r24
     744:	79 97       	sbiw	r30, 0x19	; 25
     746:	29 e1       	ldi	r18, 0x19	; 25
     748:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     74a:	fc 01       	movw	r30, r24
     74c:	7a 97       	sbiw	r30, 0x1a	; 26
     74e:	20 e2       	ldi	r18, 0x20	; 32
     750:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     752:	fc 01       	movw	r30, r24
     754:	7b 97       	sbiw	r30, 0x1b	; 27
     756:	21 e2       	ldi	r18, 0x21	; 33
     758:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     75a:	fc 01       	movw	r30, r24
     75c:	7c 97       	sbiw	r30, 0x1c	; 28
     75e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     760:	fc 01       	movw	r30, r24
     762:	7d 97       	sbiw	r30, 0x1d	; 29
     764:	23 e2       	ldi	r18, 0x23	; 35
     766:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     768:	fc 01       	movw	r30, r24
     76a:	7e 97       	sbiw	r30, 0x1e	; 30
     76c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     76e:	fc 01       	movw	r30, r24
     770:	7f 97       	sbiw	r30, 0x1f	; 31
     772:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     774:	fc 01       	movw	r30, r24
     776:	b0 97       	sbiw	r30, 0x20	; 32
     778:	26 e2       	ldi	r18, 0x26	; 38
     77a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     77c:	fc 01       	movw	r30, r24
     77e:	b1 97       	sbiw	r30, 0x21	; 33
     780:	27 e2       	ldi	r18, 0x27	; 39
     782:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     784:	fc 01       	movw	r30, r24
     786:	b2 97       	sbiw	r30, 0x22	; 34
     788:	28 e2       	ldi	r18, 0x28	; 40
     78a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     78c:	fc 01       	movw	r30, r24
     78e:	b3 97       	sbiw	r30, 0x23	; 35
     790:	29 e2       	ldi	r18, 0x29	; 41
     792:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     794:	fc 01       	movw	r30, r24
     796:	b4 97       	sbiw	r30, 0x24	; 36
     798:	20 e3       	ldi	r18, 0x30	; 48
     79a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     79c:	fc 01       	movw	r30, r24
     79e:	b5 97       	sbiw	r30, 0x25	; 37
     7a0:	21 e3       	ldi	r18, 0x31	; 49
     7a2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     7a4:	86 97       	sbiw	r24, 0x26	; 38
}
     7a6:	08 95       	ret

000007a8 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     7a8:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     7aa:	8c e7       	ldi	r24, 0x7C	; 124
     7ac:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     7ae:	8b e0       	ldi	r24, 0x0B	; 11
     7b0:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     7b2:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     7b4:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     7b6:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     7b8:	a0 91 fc 02 	lds	r26, 0x02FC
     7bc:	b0 91 fd 02 	lds	r27, 0x02FD
     7c0:	cd 91       	ld	r28, X+
     7c2:	cd bf       	out	0x3d, r28	; 61
     7c4:	dd 91       	ld	r29, X+
     7c6:	de bf       	out	0x3e, r29	; 62
     7c8:	ff 91       	pop	r31
     7ca:	ef 91       	pop	r30
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	bf 91       	pop	r27
     7d2:	af 91       	pop	r26
     7d4:	9f 91       	pop	r25
     7d6:	8f 91       	pop	r24
     7d8:	7f 91       	pop	r23
     7da:	6f 91       	pop	r22
     7dc:	5f 91       	pop	r21
     7de:	4f 91       	pop	r20
     7e0:	3f 91       	pop	r19
     7e2:	2f 91       	pop	r18
     7e4:	1f 91       	pop	r17
     7e6:	0f 91       	pop	r16
     7e8:	ff 90       	pop	r15
     7ea:	ef 90       	pop	r14
     7ec:	df 90       	pop	r13
     7ee:	cf 90       	pop	r12
     7f0:	bf 90       	pop	r11
     7f2:	af 90       	pop	r10
     7f4:	9f 90       	pop	r9
     7f6:	8f 90       	pop	r8
     7f8:	7f 90       	pop	r7
     7fa:	6f 90       	pop	r6
     7fc:	5f 90       	pop	r5
     7fe:	4f 90       	pop	r4
     800:	3f 90       	pop	r3
     802:	2f 90       	pop	r2
     804:	1f 90       	pop	r1
     806:	0f 90       	pop	r0
     808:	0f be       	out	0x3f, r0	; 63
     80a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     80c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     80e:	81 e0       	ldi	r24, 0x01	; 1
     810:	08 95       	ret

00000812 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     812:	08 95       	ret

00000814 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     814:	0f 92       	push	r0
     816:	0f b6       	in	r0, 0x3f	; 63
     818:	f8 94       	cli
     81a:	0f 92       	push	r0
     81c:	1f 92       	push	r1
     81e:	11 24       	eor	r1, r1
     820:	2f 92       	push	r2
     822:	3f 92       	push	r3
     824:	4f 92       	push	r4
     826:	5f 92       	push	r5
     828:	6f 92       	push	r6
     82a:	7f 92       	push	r7
     82c:	8f 92       	push	r8
     82e:	9f 92       	push	r9
     830:	af 92       	push	r10
     832:	bf 92       	push	r11
     834:	cf 92       	push	r12
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	2f 93       	push	r18
     842:	3f 93       	push	r19
     844:	4f 93       	push	r20
     846:	5f 93       	push	r21
     848:	6f 93       	push	r22
     84a:	7f 93       	push	r23
     84c:	8f 93       	push	r24
     84e:	9f 93       	push	r25
     850:	af 93       	push	r26
     852:	bf 93       	push	r27
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	ef 93       	push	r30
     85a:	ff 93       	push	r31
     85c:	a0 91 fc 02 	lds	r26, 0x02FC
     860:	b0 91 fd 02 	lds	r27, 0x02FD
     864:	0d b6       	in	r0, 0x3d	; 61
     866:	0d 92       	st	X+, r0
     868:	0e b6       	in	r0, 0x3e	; 62
     86a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     86c:	0e 94 c2 0b 	call	0x1784	; 0x1784 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     870:	a0 91 fc 02 	lds	r26, 0x02FC
     874:	b0 91 fd 02 	lds	r27, 0x02FD
     878:	cd 91       	ld	r28, X+
     87a:	cd bf       	out	0x3d, r28	; 61
     87c:	dd 91       	ld	r29, X+
     87e:	de bf       	out	0x3e, r29	; 62
     880:	ff 91       	pop	r31
     882:	ef 91       	pop	r30
     884:	df 91       	pop	r29
     886:	cf 91       	pop	r28
     888:	bf 91       	pop	r27
     88a:	af 91       	pop	r26
     88c:	9f 91       	pop	r25
     88e:	8f 91       	pop	r24
     890:	7f 91       	pop	r23
     892:	6f 91       	pop	r22
     894:	5f 91       	pop	r21
     896:	4f 91       	pop	r20
     898:	3f 91       	pop	r19
     89a:	2f 91       	pop	r18
     89c:	1f 91       	pop	r17
     89e:	0f 91       	pop	r16
     8a0:	ff 90       	pop	r15
     8a2:	ef 90       	pop	r14
     8a4:	df 90       	pop	r13
     8a6:	cf 90       	pop	r12
     8a8:	bf 90       	pop	r11
     8aa:	af 90       	pop	r10
     8ac:	9f 90       	pop	r9
     8ae:	8f 90       	pop	r8
     8b0:	7f 90       	pop	r7
     8b2:	6f 90       	pop	r6
     8b4:	5f 90       	pop	r5
     8b6:	4f 90       	pop	r4
     8b8:	3f 90       	pop	r3
     8ba:	2f 90       	pop	r2
     8bc:	1f 90       	pop	r1
     8be:	0f 90       	pop	r0
     8c0:	0f be       	out	0x3f, r0	; 63
     8c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8c4:	08 95       	ret

000008c6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     8c6:	0f 92       	push	r0
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	f8 94       	cli
     8cc:	0f 92       	push	r0
     8ce:	1f 92       	push	r1
     8d0:	11 24       	eor	r1, r1
     8d2:	2f 92       	push	r2
     8d4:	3f 92       	push	r3
     8d6:	4f 92       	push	r4
     8d8:	5f 92       	push	r5
     8da:	6f 92       	push	r6
     8dc:	7f 92       	push	r7
     8de:	8f 92       	push	r8
     8e0:	9f 92       	push	r9
     8e2:	af 92       	push	r10
     8e4:	bf 92       	push	r11
     8e6:	cf 92       	push	r12
     8e8:	df 92       	push	r13
     8ea:	ef 92       	push	r14
     8ec:	ff 92       	push	r15
     8ee:	0f 93       	push	r16
     8f0:	1f 93       	push	r17
     8f2:	2f 93       	push	r18
     8f4:	3f 93       	push	r19
     8f6:	4f 93       	push	r20
     8f8:	5f 93       	push	r21
     8fa:	6f 93       	push	r22
     8fc:	7f 93       	push	r23
     8fe:	8f 93       	push	r24
     900:	9f 93       	push	r25
     902:	af 93       	push	r26
     904:	bf 93       	push	r27
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	ef 93       	push	r30
     90c:	ff 93       	push	r31
     90e:	a0 91 fc 02 	lds	r26, 0x02FC
     912:	b0 91 fd 02 	lds	r27, 0x02FD
     916:	0d b6       	in	r0, 0x3d	; 61
     918:	0d 92       	st	X+, r0
     91a:	0e b6       	in	r0, 0x3e	; 62
     91c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     91e:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskIncrementTick>
	vTaskSwitchContext();
     922:	0e 94 c2 0b 	call	0x1784	; 0x1784 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     926:	a0 91 fc 02 	lds	r26, 0x02FC
     92a:	b0 91 fd 02 	lds	r27, 0x02FD
     92e:	cd 91       	ld	r28, X+
     930:	cd bf       	out	0x3d, r28	; 61
     932:	dd 91       	ld	r29, X+
     934:	de bf       	out	0x3e, r29	; 62
     936:	ff 91       	pop	r31
     938:	ef 91       	pop	r30
     93a:	df 91       	pop	r29
     93c:	cf 91       	pop	r28
     93e:	bf 91       	pop	r27
     940:	af 91       	pop	r26
     942:	9f 91       	pop	r25
     944:	8f 91       	pop	r24
     946:	7f 91       	pop	r23
     948:	6f 91       	pop	r22
     94a:	5f 91       	pop	r21
     94c:	4f 91       	pop	r20
     94e:	3f 91       	pop	r19
     950:	2f 91       	pop	r18
     952:	1f 91       	pop	r17
     954:	0f 91       	pop	r16
     956:	ff 90       	pop	r15
     958:	ef 90       	pop	r14
     95a:	df 90       	pop	r13
     95c:	cf 90       	pop	r12
     95e:	bf 90       	pop	r11
     960:	af 90       	pop	r10
     962:	9f 90       	pop	r9
     964:	8f 90       	pop	r8
     966:	7f 90       	pop	r7
     968:	6f 90       	pop	r6
     96a:	5f 90       	pop	r5
     96c:	4f 90       	pop	r4
     96e:	3f 90       	pop	r3
     970:	2f 90       	pop	r2
     972:	1f 90       	pop	r1
     974:	0f 90       	pop	r0
     976:	0f be       	out	0x3f, r0	; 63
     978:	0f 90       	pop	r0

	asm volatile ( "ret" );
     97a:	08 95       	ret

0000097c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     97c:	0e 94 63 04 	call	0x8c6	; 0x8c6 <vPortYieldFromTick>
		asm volatile ( "reti" );
     980:	18 95       	reti

00000982 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     982:	cf 93       	push	r28
     984:	df 93       	push	r29
     986:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     988:	cd 91       	ld	r28, X+
     98a:	dc 91       	ld	r29, X
     98c:	11 97       	sbiw	r26, 0x01	; 1
     98e:	20 97       	sbiw	r28, 0x00	; 0
     990:	21 f1       	breq	.+72     	; 0x9da <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     992:	5c 96       	adiw	r26, 0x1c	; 28
     994:	4c 91       	ld	r20, X
     996:	5c 97       	sbiw	r26, 0x1c	; 28
     998:	16 96       	adiw	r26, 0x06	; 6
     99a:	2d 91       	ld	r18, X+
     99c:	3c 91       	ld	r19, X
     99e:	17 97       	sbiw	r26, 0x07	; 7
     9a0:	24 0f       	add	r18, r20
     9a2:	31 1d       	adc	r19, r1
     9a4:	17 96       	adiw	r26, 0x07	; 7
     9a6:	3c 93       	st	X, r19
     9a8:	2e 93       	st	-X, r18
     9aa:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     9ac:	12 96       	adiw	r26, 0x02	; 2
     9ae:	ed 91       	ld	r30, X+
     9b0:	fc 91       	ld	r31, X
     9b2:	13 97       	sbiw	r26, 0x03	; 3
     9b4:	2e 17       	cp	r18, r30
     9b6:	3f 07       	cpc	r19, r31
     9b8:	20 f0       	brcs	.+8      	; 0x9c2 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     9ba:	17 96       	adiw	r26, 0x07	; 7
     9bc:	dc 93       	st	X, r29
     9be:	ce 93       	st	-X, r28
     9c0:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     9c2:	16 96       	adiw	r26, 0x06	; 6
     9c4:	3c 91       	ld	r19, X
     9c6:	16 97       	sbiw	r26, 0x06	; 6
     9c8:	17 96       	adiw	r26, 0x07	; 7
     9ca:	2c 91       	ld	r18, X
     9cc:	86 2f       	mov	r24, r22
     9ce:	97 2f       	mov	r25, r23
     9d0:	63 2f       	mov	r22, r19
     9d2:	72 2f       	mov	r23, r18
     9d4:	50 e0       	ldi	r21, 0x00	; 0
     9d6:	0e 94 c9 0c 	call	0x1992	; 0x1992 <memcpy>
	}
}
     9da:	df 91       	pop	r29
     9dc:	cf 91       	pop	r28
     9de:	08 95       	ret

000009e0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     9e0:	cf 93       	push	r28
     9e2:	df 93       	push	r29
     9e4:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     9e6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     9e8:	22 23       	and	r18, r18
     9ea:	a9 f1       	breq	.+106    	; 0xa56 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     9ec:	44 23       	and	r20, r20
     9ee:	b9 f4       	brne	.+46     	; 0xa1e <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     9f0:	8c 81       	ldd	r24, Y+4	; 0x04
     9f2:	9d 81       	ldd	r25, Y+5	; 0x05
     9f4:	42 2f       	mov	r20, r18
     9f6:	50 e0       	ldi	r21, 0x00	; 0
     9f8:	0e 94 c9 0c 	call	0x1992	; 0x1992 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     9fc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     9fe:	8c 81       	ldd	r24, Y+4	; 0x04
     a00:	9d 81       	ldd	r25, Y+5	; 0x05
     a02:	82 0f       	add	r24, r18
     a04:	91 1d       	adc	r25, r1
     a06:	9d 83       	std	Y+5, r25	; 0x05
     a08:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     a0a:	2a 81       	ldd	r18, Y+2	; 0x02
     a0c:	3b 81       	ldd	r19, Y+3	; 0x03
     a0e:	82 17       	cp	r24, r18
     a10:	93 07       	cpc	r25, r19
     a12:	08 f1       	brcs	.+66     	; 0xa56 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     a14:	88 81       	ld	r24, Y
     a16:	99 81       	ldd	r25, Y+1	; 0x01
     a18:	9d 83       	std	Y+5, r25	; 0x05
     a1a:	8c 83       	std	Y+4, r24	; 0x04
     a1c:	1c c0       	rjmp	.+56     	; 0xa56 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     a1e:	8e 81       	ldd	r24, Y+6	; 0x06
     a20:	9f 81       	ldd	r25, Y+7	; 0x07
     a22:	42 2f       	mov	r20, r18
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	0e 94 c9 0c 	call	0x1992	; 0x1992 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     a2a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a2c:	50 e0       	ldi	r21, 0x00	; 0
     a2e:	50 95       	com	r21
     a30:	41 95       	neg	r20
     a32:	5f 4f       	sbci	r21, 0xFF	; 255
     a34:	8e 81       	ldd	r24, Y+6	; 0x06
     a36:	9f 81       	ldd	r25, Y+7	; 0x07
     a38:	84 0f       	add	r24, r20
     a3a:	95 1f       	adc	r25, r21
     a3c:	9f 83       	std	Y+7, r25	; 0x07
     a3e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     a40:	28 81       	ld	r18, Y
     a42:	39 81       	ldd	r19, Y+1	; 0x01
     a44:	82 17       	cp	r24, r18
     a46:	93 07       	cpc	r25, r19
     a48:	30 f4       	brcc	.+12     	; 0xa56 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     a4a:	8a 81       	ldd	r24, Y+2	; 0x02
     a4c:	9b 81       	ldd	r25, Y+3	; 0x03
     a4e:	48 0f       	add	r20, r24
     a50:	59 1f       	adc	r21, r25
     a52:	5f 83       	std	Y+7, r21	; 0x07
     a54:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     a56:	8a 8d       	ldd	r24, Y+26	; 0x1a
     a58:	8f 5f       	subi	r24, 0xFF	; 255
     a5a:	8a 8f       	std	Y+26, r24	; 0x1a
}
     a5c:	df 91       	pop	r29
     a5e:	cf 91       	pop	r28
     a60:	08 95       	ret

00000a62 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     a62:	0f 93       	push	r16
     a64:	1f 93       	push	r17
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     a6c:	0f b6       	in	r0, 0x3f	; 63
     a6e:	f8 94       	cli
     a70:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     a72:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a74:	18 16       	cp	r1, r24
     a76:	bc f4       	brge	.+46     	; 0xaa6 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a78:	89 89       	ldd	r24, Y+17	; 0x11
     a7a:	88 23       	and	r24, r24
     a7c:	29 f4       	brne	.+10     	; 0xa88 <prvUnlockQueue+0x26>
     a7e:	13 c0       	rjmp	.+38     	; 0xaa6 <prvUnlockQueue+0x44>
     a80:	89 89       	ldd	r24, Y+17	; 0x11
     a82:	88 23       	and	r24, r24
     a84:	21 f4       	brne	.+8      	; 0xa8e <prvUnlockQueue+0x2c>
     a86:	0f c0       	rjmp	.+30     	; 0xaa6 <prvUnlockQueue+0x44>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a88:	8e 01       	movw	r16, r28
     a8a:	0f 5e       	subi	r16, 0xEF	; 239
     a8c:	1f 4f       	sbci	r17, 0xFF	; 255
     a8e:	c8 01       	movw	r24, r16
     a90:	0e 94 3c 0c 	call	0x1878	; 0x1878 <xTaskRemoveFromEventList>
     a94:	88 23       	and	r24, r24
     a96:	11 f0       	breq	.+4      	; 0xa9c <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     a98:	0e 94 c5 0c 	call	0x198a	; 0x198a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     a9c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a9e:	81 50       	subi	r24, 0x01	; 1
     aa0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     aa2:	18 16       	cp	r1, r24
     aa4:	6c f3       	brlt	.-38     	; 0xa80 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     aa6:	8f ef       	ldi	r24, 0xFF	; 255
     aa8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     aaa:	0f 90       	pop	r0
     aac:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     aae:	0f b6       	in	r0, 0x3f	; 63
     ab0:	f8 94       	cli
     ab2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ab4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ab6:	18 16       	cp	r1, r24
     ab8:	bc f4       	brge	.+46     	; 0xae8 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     aba:	88 85       	ldd	r24, Y+8	; 0x08
     abc:	88 23       	and	r24, r24
     abe:	29 f4       	brne	.+10     	; 0xaca <prvUnlockQueue+0x68>
     ac0:	13 c0       	rjmp	.+38     	; 0xae8 <prvUnlockQueue+0x86>
     ac2:	88 85       	ldd	r24, Y+8	; 0x08
     ac4:	88 23       	and	r24, r24
     ac6:	21 f4       	brne	.+8      	; 0xad0 <prvUnlockQueue+0x6e>
     ac8:	0f c0       	rjmp	.+30     	; 0xae8 <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     aca:	8e 01       	movw	r16, r28
     acc:	08 5f       	subi	r16, 0xF8	; 248
     ace:	1f 4f       	sbci	r17, 0xFF	; 255
     ad0:	c8 01       	movw	r24, r16
     ad2:	0e 94 3c 0c 	call	0x1878	; 0x1878 <xTaskRemoveFromEventList>
     ad6:	88 23       	and	r24, r24
     ad8:	11 f0       	breq	.+4      	; 0xade <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
     ada:	0e 94 c5 0c 	call	0x198a	; 0x198a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     ade:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ae4:	18 16       	cp	r1, r24
     ae6:	6c f3       	brlt	.-38     	; 0xac2 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     ae8:	8f ef       	ldi	r24, 0xFF	; 255
     aea:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     aec:	0f 90       	pop	r0
     aee:	0f be       	out	0x3f, r0	; 63
}
     af0:	df 91       	pop	r29
     af2:	cf 91       	pop	r28
     af4:	1f 91       	pop	r17
     af6:	0f 91       	pop	r16
     af8:	08 95       	ret

00000afa <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     afa:	af 92       	push	r10
     afc:	bf 92       	push	r11
     afe:	cf 92       	push	r12
     b00:	df 92       	push	r13
     b02:	ef 92       	push	r14
     b04:	ff 92       	push	r15
     b06:	0f 93       	push	r16
     b08:	1f 93       	push	r17
     b0a:	cf 93       	push	r28
     b0c:	df 93       	push	r29
     b0e:	f8 2e       	mov	r15, r24
     b10:	e6 2e       	mov	r14, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     b12:	88 23       	and	r24, r24
     b14:	09 f4       	brne	.+2      	; 0xb18 <xQueueCreate+0x1e>
     b16:	46 c0       	rjmp	.+140    	; 0xba4 <xQueueCreate+0xaa>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     b18:	8f e1       	ldi	r24, 0x1F	; 31
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
     b20:	8c 01       	movw	r16, r24
		if( pxNewQueue != NULL )
     b22:	00 97       	sbiw	r24, 0x00	; 0
     b24:	09 f4       	brne	.+2      	; 0xb28 <xQueueCreate+0x2e>
     b26:	41 c0       	rjmp	.+130    	; 0xbaa <xQueueCreate+0xb0>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     b28:	cf 2c       	mov	r12, r15
     b2a:	dd 24       	eor	r13, r13
     b2c:	ae 2c       	mov	r10, r14
     b2e:	bb 24       	eor	r11, r11
     b30:	ca 9c       	mul	r12, r10
     b32:	e0 01       	movw	r28, r0
     b34:	cb 9c       	mul	r12, r11
     b36:	d0 0d       	add	r29, r0
     b38:	da 9c       	mul	r13, r10
     b3a:	d0 0d       	add	r29, r0
     b3c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     b3e:	ce 01       	movw	r24, r28
     b40:	01 96       	adiw	r24, 0x01	; 1
     b42:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
     b46:	ac 01       	movw	r20, r24
     b48:	f8 01       	movw	r30, r16
     b4a:	91 83       	std	Z+1, r25	; 0x01
     b4c:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
     b4e:	00 97       	sbiw	r24, 0x00	; 0
     b50:	19 f1       	breq	.+70     	; 0xb98 <xQueueCreate+0x9e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     b52:	c8 0f       	add	r28, r24
     b54:	d9 1f       	adc	r29, r25
     b56:	d3 83       	std	Z+3, r29	; 0x03
     b58:	c2 83       	std	Z+2, r28	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     b5a:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     b5c:	95 83       	std	Z+5, r25	; 0x05
     b5e:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
     b60:	c6 01       	movw	r24, r12
     b62:	01 97       	sbiw	r24, 0x01	; 1
     b64:	a8 9e       	mul	r10, r24
     b66:	90 01       	movw	r18, r0
     b68:	a9 9e       	mul	r10, r25
     b6a:	30 0d       	add	r19, r0
     b6c:	b8 9e       	mul	r11, r24
     b6e:	30 0d       	add	r19, r0
     b70:	11 24       	eor	r1, r1
     b72:	24 0f       	add	r18, r20
     b74:	35 1f       	adc	r19, r21
     b76:	37 83       	std	Z+7, r19	; 0x07
     b78:	26 83       	std	Z+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     b7a:	f3 8e       	std	Z+27, r15	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     b7c:	e4 8e       	std	Z+28, r14	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     b82:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     b84:	c8 01       	movw	r24, r16
     b86:	08 96       	adiw	r24, 0x08	; 8
     b88:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     b8c:	c8 01       	movw	r24, r16
     b8e:	41 96       	adiw	r24, 0x11	; 17
     b90:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     b94:	c8 01       	movw	r24, r16
     b96:	0b c0       	rjmp	.+22     	; 0xbae <xQueueCreate+0xb4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     b98:	c8 01       	movw	r24, r16
     b9a:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     b9e:	80 e0       	ldi	r24, 0x00	; 0
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	05 c0       	rjmp	.+10     	; 0xbae <xQueueCreate+0xb4>
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	02 c0       	rjmp	.+4      	; 0xbae <xQueueCreate+0xb4>
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	1f 91       	pop	r17
     bb4:	0f 91       	pop	r16
     bb6:	ff 90       	pop	r15
     bb8:	ef 90       	pop	r14
     bba:	df 90       	pop	r13
     bbc:	cf 90       	pop	r12
     bbe:	bf 90       	pop	r11
     bc0:	af 90       	pop	r10
     bc2:	08 95       	ret

00000bc4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     bc4:	8f 92       	push	r8
     bc6:	9f 92       	push	r9
     bc8:	bf 92       	push	r11
     bca:	cf 92       	push	r12
     bcc:	df 92       	push	r13
     bce:	ef 92       	push	r14
     bd0:	ff 92       	push	r15
     bd2:	0f 93       	push	r16
     bd4:	1f 93       	push	r17
     bd6:	cf 93       	push	r28
     bd8:	df 93       	push	r29
     bda:	00 d0       	rcall	.+0      	; 0xbdc <xQueueGenericSend+0x18>
     bdc:	00 d0       	rcall	.+0      	; 0xbde <xQueueGenericSend+0x1a>
     bde:	0f 92       	push	r0
     be0:	cd b7       	in	r28, 0x3d	; 61
     be2:	de b7       	in	r29, 0x3e	; 62
     be4:	8c 01       	movw	r16, r24
     be6:	4b 01       	movw	r8, r22
     be8:	5d 83       	std	Y+5, r21	; 0x05
     bea:	4c 83       	std	Y+4, r20	; 0x04
     bec:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     bee:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     bf0:	ee 24       	eor	r14, r14
     bf2:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     bf4:	cc 24       	eor	r12, r12
     bf6:	dd 24       	eor	r13, r13
     bf8:	68 94       	set
     bfa:	c3 f8       	bld	r12, 3
     bfc:	c8 0e       	add	r12, r24
     bfe:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     c00:	0f b6       	in	r0, 0x3f	; 63
     c02:	f8 94       	cli
     c04:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     c06:	f8 01       	movw	r30, r16
     c08:	92 8d       	ldd	r25, Z+26	; 0x1a
     c0a:	83 8d       	ldd	r24, Z+27	; 0x1b
     c0c:	98 17       	cp	r25, r24
     c0e:	a8 f4       	brcc	.+42     	; 0xc3a <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     c10:	c8 01       	movw	r24, r16
     c12:	b4 01       	movw	r22, r8
     c14:	4b 2d       	mov	r20, r11
     c16:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c1a:	f8 01       	movw	r30, r16
     c1c:	81 89       	ldd	r24, Z+17	; 0x11
     c1e:	88 23       	and	r24, r24
     c20:	41 f0       	breq	.+16     	; 0xc32 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     c22:	c8 01       	movw	r24, r16
     c24:	41 96       	adiw	r24, 0x11	; 17
     c26:	0e 94 3c 0c 	call	0x1878	; 0x1878 <xTaskRemoveFromEventList>
     c2a:	81 30       	cpi	r24, 0x01	; 1
     c2c:	11 f4       	brne	.+4      	; 0xc32 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     c2e:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	52 c0       	rjmp	.+164    	; 0xcde <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     c3a:	8c 81       	ldd	r24, Y+4	; 0x04
     c3c:	9d 81       	ldd	r25, Y+5	; 0x05
     c3e:	00 97       	sbiw	r24, 0x00	; 0
     c40:	21 f4       	brne	.+8      	; 0xc4a <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     c42:	0f 90       	pop	r0
     c44:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	4a c0       	rjmp	.+148    	; 0xcde <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
     c4a:	ff 20       	and	r15, r15
     c4c:	29 f4       	brne	.+10     	; 0xc58 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     c4e:	ce 01       	movw	r24, r28
     c50:	01 96       	adiw	r24, 0x01	; 1
     c52:	0e 94 84 0c 	call	0x1908	; 0x1908 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     c56:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     c58:	0f 90       	pop	r0
     c5a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     c5c:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	0f 92       	push	r0
     c66:	f8 01       	movw	r30, r16
     c68:	85 8d       	ldd	r24, Z+29	; 0x1d
     c6a:	8f 3f       	cpi	r24, 0xFF	; 255
     c6c:	09 f4       	brne	.+2      	; 0xc70 <xQueueGenericSend+0xac>
     c6e:	15 8e       	std	Z+29, r1	; 0x1d
     c70:	f8 01       	movw	r30, r16
     c72:	86 8d       	ldd	r24, Z+30	; 0x1e
     c74:	8f 3f       	cpi	r24, 0xFF	; 255
     c76:	09 f4       	brne	.+2      	; 0xc7a <xQueueGenericSend+0xb6>
     c78:	16 8e       	std	Z+30, r1	; 0x1e
     c7a:	0f 90       	pop	r0
     c7c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c7e:	ce 01       	movw	r24, r28
     c80:	01 96       	adiw	r24, 0x01	; 1
     c82:	be 01       	movw	r22, r28
     c84:	6c 5f       	subi	r22, 0xFC	; 252
     c86:	7f 4f       	sbci	r23, 0xFF	; 255
     c88:	0e 94 8f 0c 	call	0x191e	; 0x191e <xTaskCheckForTimeOut>
     c8c:	88 23       	and	r24, r24
     c8e:	09 f5       	brne	.+66     	; 0xcd2 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     c90:	0f b6       	in	r0, 0x3f	; 63
     c92:	f8 94       	cli
     c94:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     c96:	f8 01       	movw	r30, r16
     c98:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     c9a:	0f 90       	pop	r0
     c9c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     c9e:	f8 01       	movw	r30, r16
     ca0:	83 8d       	ldd	r24, Z+27	; 0x1b
     ca2:	98 17       	cp	r25, r24
     ca4:	81 f4       	brne	.+32     	; 0xcc6 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ca6:	6c 81       	ldd	r22, Y+4	; 0x04
     ca8:	7d 81       	ldd	r23, Y+5	; 0x05
     caa:	c6 01       	movw	r24, r12
     cac:	0e 94 1f 0c 	call	0x183e	; 0x183e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     cb0:	c8 01       	movw	r24, r16
     cb2:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     cb6:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>
     cba:	88 23       	and	r24, r24
     cbc:	09 f0       	breq	.+2      	; 0xcc0 <xQueueGenericSend+0xfc>
     cbe:	a0 cf       	rjmp	.-192    	; 0xc00 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     cc0:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
     cc4:	9d cf       	rjmp	.-198    	; 0xc00 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     cc6:	c8 01       	movw	r24, r16
     cc8:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     ccc:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>
     cd0:	97 cf       	rjmp	.-210    	; 0xc00 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     cd2:	c8 01       	movw	r24, r16
     cd4:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     cd8:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     cdc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     cde:	0f 90       	pop	r0
     ce0:	0f 90       	pop	r0
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	0f 90       	pop	r0
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	1f 91       	pop	r17
     cee:	0f 91       	pop	r16
     cf0:	ff 90       	pop	r15
     cf2:	ef 90       	pop	r14
     cf4:	df 90       	pop	r13
     cf6:	cf 90       	pop	r12
     cf8:	bf 90       	pop	r11
     cfa:	9f 90       	pop	r9
     cfc:	8f 90       	pop	r8
     cfe:	08 95       	ret

00000d00 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     d00:	0f 93       	push	r16
     d02:	1f 93       	push	r17
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	ec 01       	movw	r28, r24
     d0a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     d0c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     d0e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d10:	98 17       	cp	r25, r24
     d12:	c0 f4       	brcc	.+48     	; 0xd44 <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d14:	ce 01       	movw	r24, r28
     d16:	42 2f       	mov	r20, r18
     d18:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     d1c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d1e:	8f 3f       	cpi	r24, 0xFF	; 255
     d20:	69 f4       	brne	.+26     	; 0xd3c <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d22:	89 89       	ldd	r24, Y+17	; 0x11
     d24:	88 23       	and	r24, r24
     d26:	81 f0       	breq	.+32     	; 0xd48 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d28:	ce 01       	movw	r24, r28
     d2a:	41 96       	adiw	r24, 0x11	; 17
     d2c:	0e 94 3c 0c 	call	0x1878	; 0x1878 <xTaskRemoveFromEventList>
     d30:	88 23       	and	r24, r24
     d32:	61 f0       	breq	.+24     	; 0xd4c <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	f8 01       	movw	r30, r16
     d38:	80 83       	st	Z, r24
     d3a:	09 c0       	rjmp	.+18     	; 0xd4e <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     d3c:	8f 5f       	subi	r24, 0xFF	; 255
     d3e:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     d40:	81 e0       	ldi	r24, 0x01	; 1
     d42:	05 c0       	rjmp	.+10     	; 0xd4e <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     d44:	80 e0       	ldi	r24, 0x00	; 0
     d46:	03 c0       	rjmp	.+6      	; 0xd4e <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	01 c0       	rjmp	.+2      	; 0xd4e <xQueueGenericSendFromISR+0x4e>
     d4c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d4e:	df 91       	pop	r29
     d50:	cf 91       	pop	r28
     d52:	1f 91       	pop	r17
     d54:	0f 91       	pop	r16
     d56:	08 95       	ret

00000d58 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     d58:	8f 92       	push	r8
     d5a:	9f 92       	push	r9
     d5c:	bf 92       	push	r11
     d5e:	cf 92       	push	r12
     d60:	df 92       	push	r13
     d62:	ef 92       	push	r14
     d64:	ff 92       	push	r15
     d66:	0f 93       	push	r16
     d68:	1f 93       	push	r17
     d6a:	cf 93       	push	r28
     d6c:	df 93       	push	r29
     d6e:	00 d0       	rcall	.+0      	; 0xd70 <xQueueGenericReceive+0x18>
     d70:	00 d0       	rcall	.+0      	; 0xd72 <xQueueGenericReceive+0x1a>
     d72:	0f 92       	push	r0
     d74:	cd b7       	in	r28, 0x3d	; 61
     d76:	de b7       	in	r29, 0x3e	; 62
     d78:	8c 01       	movw	r16, r24
     d7a:	4b 01       	movw	r8, r22
     d7c:	5d 83       	std	Y+5, r21	; 0x05
     d7e:	4c 83       	std	Y+4, r20	; 0x04
     d80:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     d82:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     d84:	ee 24       	eor	r14, r14
     d86:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d88:	0f 2e       	mov	r0, r31
     d8a:	f1 e1       	ldi	r31, 0x11	; 17
     d8c:	cf 2e       	mov	r12, r31
     d8e:	dd 24       	eor	r13, r13
     d90:	f0 2d       	mov	r31, r0
     d92:	c8 0e       	add	r12, r24
     d94:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     d96:	0f b6       	in	r0, 0x3f	; 63
     d98:	f8 94       	cli
     d9a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     d9c:	f8 01       	movw	r30, r16
     d9e:	82 8d       	ldd	r24, Z+26	; 0x1a
     da0:	88 23       	and	r24, r24
     da2:	51 f1       	breq	.+84     	; 0xdf8 <xQueueGenericReceive+0xa0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     da4:	e6 80       	ldd	r14, Z+6	; 0x06
     da6:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     da8:	c8 01       	movw	r24, r16
     daa:	b4 01       	movw	r22, r8
     dac:	0e 94 c1 04 	call	0x982	; 0x982 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     db0:	bb 20       	and	r11, r11
     db2:	81 f4       	brne	.+32     	; 0xdd4 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     db4:	f8 01       	movw	r30, r16
     db6:	82 8d       	ldd	r24, Z+26	; 0x1a
     db8:	81 50       	subi	r24, 0x01	; 1
     dba:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     dbc:	80 85       	ldd	r24, Z+8	; 0x08
     dbe:	88 23       	and	r24, r24
     dc0:	b9 f0       	breq	.+46     	; 0xdf0 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     dc2:	c8 01       	movw	r24, r16
     dc4:	08 96       	adiw	r24, 0x08	; 8
     dc6:	0e 94 3c 0c 	call	0x1878	; 0x1878 <xTaskRemoveFromEventList>
     dca:	81 30       	cpi	r24, 0x01	; 1
     dcc:	89 f4       	brne	.+34     	; 0xdf0 <xQueueGenericReceive+0x98>
						{
							portYIELD_WITHIN_API();
     dce:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
     dd2:	0e c0       	rjmp	.+28     	; 0xdf0 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     dd4:	f8 01       	movw	r30, r16
     dd6:	f7 82       	std	Z+7, r15	; 0x07
     dd8:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dda:	81 89       	ldd	r24, Z+17	; 0x11
     ddc:	88 23       	and	r24, r24
     dde:	41 f0       	breq	.+16     	; 0xdf0 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     de0:	c8 01       	movw	r24, r16
     de2:	41 96       	adiw	r24, 0x11	; 17
     de4:	0e 94 3c 0c 	call	0x1878	; 0x1878 <xTaskRemoveFromEventList>
     de8:	88 23       	and	r24, r24
     dea:	11 f0       	breq	.+4      	; 0xdf0 <xQueueGenericReceive+0x98>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     dec:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     df0:	0f 90       	pop	r0
     df2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     df4:	81 e0       	ldi	r24, 0x01	; 1
     df6:	50 c0       	rjmp	.+160    	; 0xe98 <xQueueGenericReceive+0x140>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     df8:	8c 81       	ldd	r24, Y+4	; 0x04
     dfa:	9d 81       	ldd	r25, Y+5	; 0x05
     dfc:	00 97       	sbiw	r24, 0x00	; 0
     dfe:	21 f4       	brne	.+8      	; 0xe08 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e00:	0f 90       	pop	r0
     e02:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e04:	80 e0       	ldi	r24, 0x00	; 0
     e06:	48 c0       	rjmp	.+144    	; 0xe98 <xQueueGenericReceive+0x140>
				}
				else if( xEntryTimeSet == pdFALSE )
     e08:	ff 20       	and	r15, r15
     e0a:	29 f4       	brne	.+10     	; 0xe16 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e0c:	ce 01       	movw	r24, r28
     e0e:	01 96       	adiw	r24, 0x01	; 1
     e10:	0e 94 84 0c 	call	0x1908	; 0x1908 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e14:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
     e16:	0f 90       	pop	r0
     e18:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e1a:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e1e:	0f b6       	in	r0, 0x3f	; 63
     e20:	f8 94       	cli
     e22:	0f 92       	push	r0
     e24:	f8 01       	movw	r30, r16
     e26:	85 8d       	ldd	r24, Z+29	; 0x1d
     e28:	8f 3f       	cpi	r24, 0xFF	; 255
     e2a:	09 f4       	brne	.+2      	; 0xe2e <xQueueGenericReceive+0xd6>
     e2c:	15 8e       	std	Z+29, r1	; 0x1d
     e2e:	f8 01       	movw	r30, r16
     e30:	86 8d       	ldd	r24, Z+30	; 0x1e
     e32:	8f 3f       	cpi	r24, 0xFF	; 255
     e34:	09 f4       	brne	.+2      	; 0xe38 <xQueueGenericReceive+0xe0>
     e36:	16 8e       	std	Z+30, r1	; 0x1e
     e38:	0f 90       	pop	r0
     e3a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e3c:	ce 01       	movw	r24, r28
     e3e:	01 96       	adiw	r24, 0x01	; 1
     e40:	be 01       	movw	r22, r28
     e42:	6c 5f       	subi	r22, 0xFC	; 252
     e44:	7f 4f       	sbci	r23, 0xFF	; 255
     e46:	0e 94 8f 0c 	call	0x191e	; 0x191e <xTaskCheckForTimeOut>
     e4a:	88 23       	and	r24, r24
     e4c:	f9 f4       	brne	.+62     	; 0xe8c <xQueueGenericReceive+0x134>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     e54:	f8 01       	movw	r30, r16
     e56:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     e58:	0f 90       	pop	r0
     e5a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e5c:	88 23       	and	r24, r24
     e5e:	81 f4       	brne	.+32     	; 0xe80 <xQueueGenericReceive+0x128>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e60:	6c 81       	ldd	r22, Y+4	; 0x04
     e62:	7d 81       	ldd	r23, Y+5	; 0x05
     e64:	c6 01       	movw	r24, r12
     e66:	0e 94 1f 0c 	call	0x183e	; 0x183e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     e6a:	c8 01       	movw	r24, r16
     e6c:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     e70:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>
     e74:	88 23       	and	r24, r24
     e76:	09 f0       	breq	.+2      	; 0xe7a <xQueueGenericReceive+0x122>
     e78:	8e cf       	rjmp	.-228    	; 0xd96 <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
     e7a:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
     e7e:	8b cf       	rjmp	.-234    	; 0xd96 <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e80:	c8 01       	movw	r24, r16
     e82:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e86:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>
     e8a:	85 cf       	rjmp	.-246    	; 0xd96 <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     e8c:	c8 01       	movw	r24, r16
     e8e:	0e 94 31 05 	call	0xa62	; 0xa62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e92:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     e96:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     e98:	0f 90       	pop	r0
     e9a:	0f 90       	pop	r0
     e9c:	0f 90       	pop	r0
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	ff 90       	pop	r15
     eac:	ef 90       	pop	r14
     eae:	df 90       	pop	r13
     eb0:	cf 90       	pop	r12
     eb2:	bf 90       	pop	r11
     eb4:	9f 90       	pop	r9
     eb6:	8f 90       	pop	r8
     eb8:	08 95       	ret

00000eba <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     eba:	0f 93       	push	r16
     ebc:	1f 93       	push	r17
     ebe:	cf 93       	push	r28
     ec0:	df 93       	push	r29
     ec2:	ec 01       	movw	r28, r24
     ec4:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ec6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ec8:	88 23       	and	r24, r24
     eca:	d1 f0       	breq	.+52     	; 0xf00 <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     ecc:	ce 01       	movw	r24, r28
     ece:	0e 94 c1 04 	call	0x982	; 0x982 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
     ed2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ed4:	81 50       	subi	r24, 0x01	; 1
     ed6:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     ed8:	8d 8d       	ldd	r24, Y+29	; 0x1d
     eda:	8f 3f       	cpi	r24, 0xFF	; 255
     edc:	69 f4       	brne	.+26     	; 0xef8 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ede:	88 85       	ldd	r24, Y+8	; 0x08
     ee0:	88 23       	and	r24, r24
     ee2:	81 f0       	breq	.+32     	; 0xf04 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ee4:	ce 01       	movw	r24, r28
     ee6:	08 96       	adiw	r24, 0x08	; 8
     ee8:	0e 94 3c 0c 	call	0x1878	; 0x1878 <xTaskRemoveFromEventList>
     eec:	88 23       	and	r24, r24
     eee:	61 f0       	breq	.+24     	; 0xf08 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     ef0:	81 e0       	ldi	r24, 0x01	; 1
     ef2:	f8 01       	movw	r30, r16
     ef4:	80 83       	st	Z, r24
     ef6:	09 c0       	rjmp	.+18     	; 0xf0a <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     ef8:	8f 5f       	subi	r24, 0xFF	; 255
     efa:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
     efc:	81 e0       	ldi	r24, 0x01	; 1
     efe:	05 c0       	rjmp	.+10     	; 0xf0a <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
     f00:	80 e0       	ldi	r24, 0x00	; 0
     f02:	03 c0       	rjmp	.+6      	; 0xf0a <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
     f04:	81 e0       	ldi	r24, 0x01	; 1
     f06:	01 c0       	rjmp	.+2      	; 0xf0a <xQueueReceiveFromISR+0x50>
     f08:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f0a:	df 91       	pop	r29
     f0c:	cf 91       	pop	r28
     f0e:	1f 91       	pop	r17
     f10:	0f 91       	pop	r16
     f12:	08 95       	ret

00000f14 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     f1a:	fc 01       	movw	r30, r24
     f1c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f1e:	0f 90       	pop	r0
     f20:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     f22:	08 95       	ret

00000f24 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
     f24:	fc 01       	movw	r30, r24
     f26:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     f28:	08 95       	ret

00000f2a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     f2a:	cf 93       	push	r28
     f2c:	df 93       	push	r29
     f2e:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     f30:	88 81       	ld	r24, Y
     f32:	99 81       	ldd	r25, Y+1	; 0x01
     f34:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
	vPortFree( pxQueue );
     f38:	ce 01       	movw	r24, r28
     f3a:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
}
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	08 95       	ret

00000f44 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     f44:	fc 01       	movw	r30, r24
     f46:	92 8d       	ldd	r25, Z+26	; 0x1a
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	91 11       	cpse	r25, r1
     f4c:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
     f4e:	08 95       	ret

00000f50 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     f50:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     f52:	22 8d       	ldd	r18, Z+26	; 0x1a
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	93 8d       	ldd	r25, Z+27	; 0x1b
     f58:	29 13       	cpse	r18, r25
     f5a:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
     f5c:	08 95       	ret

00000f5e <Blink_1000ms_task>:
	}
}
//--------------------------------------------------
void Blink_1000ms_task( void *pvParameters)
{
	DDRB |=(1<<0); //PB.0 is output
     f5e:	b8 9a       	sbi	0x17, 0	; 23
	
	while(1)
	{
		
		PORTB ^= (1<<0); //toggle PB.0
     f60:	c1 e0       	ldi	r28, 0x01	; 1
     f62:	88 b3       	in	r24, 0x18	; 24
     f64:	8c 27       	eor	r24, r28
     f66:	88 bb       	out	0x18, r24	; 24
		vTaskDelay(1000); //OS Delay
     f68:	88 ee       	ldi	r24, 0xE8	; 232
     f6a:	93 e0       	ldi	r25, 0x03	; 3
     f6c:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <vTaskDelay>
     f70:	f8 cf       	rjmp	.-16     	; 0xf62 <Blink_1000ms_task+0x4>

00000f72 <Blink_200ms_task>:
#include "FreeRTOS.h"
#include "task.h"
//================= [Tasks] ===============
void Blink_200ms_task( void *pvParameters)
{
	DDRA |=(1<<0); //PA.0 is output
     f72:	d0 9a       	sbi	0x1a, 0	; 26
	
	while(1)
	{
		
		PORTA ^= (1<<0); //toggle PA.0
     f74:	c1 e0       	ldi	r28, 0x01	; 1
     f76:	8b b3       	in	r24, 0x1b	; 27
     f78:	8c 27       	eor	r24, r28
     f7a:	8b bb       	out	0x1b, r24	; 27
		vTaskDelay(200); //OS Delay
     f7c:	88 ec       	ldi	r24, 0xC8	; 200
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <vTaskDelay>
     f84:	f8 cf       	rjmp	.-16     	; 0xf76 <Blink_200ms_task+0x4>

00000f86 <main>:

//================= [Main] ====================
#include <avr/io.h>

int main(void)
{
     f86:	af 92       	push	r10
     f88:	bf 92       	push	r11
     f8a:	cf 92       	push	r12
     f8c:	df 92       	push	r13
     f8e:	ef 92       	push	r14
     f90:	ff 92       	push	r15
     f92:	0f 93       	push	r16
	// Create Tasks
	xTaskCreate( Blink_200ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     f94:	89 eb       	ldi	r24, 0xB9	; 185
     f96:	97 e0       	ldi	r25, 0x07	; 7
     f98:	60 e0       	ldi	r22, 0x00	; 0
     f9a:	70 e0       	ldi	r23, 0x00	; 0
     f9c:	45 e5       	ldi	r20, 0x55	; 85
     f9e:	50 e0       	ldi	r21, 0x00	; 0
     fa0:	20 e0       	ldi	r18, 0x00	; 0
     fa2:	30 e0       	ldi	r19, 0x00	; 0
     fa4:	01 e0       	ldi	r16, 0x01	; 1
     fa6:	ee 24       	eor	r14, r14
     fa8:	ff 24       	eor	r15, r15
     faa:	cc 24       	eor	r12, r12
     fac:	dd 24       	eor	r13, r13
     fae:	aa 24       	eor	r10, r10
     fb0:	bb 24       	eor	r11, r11
     fb2:	0e 94 29 08 	call	0x1052	; 0x1052 <xTaskGenericCreate>
	xTaskCreate( Blink_1000ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
     fb6:	8f ea       	ldi	r24, 0xAF	; 175
     fb8:	97 e0       	ldi	r25, 0x07	; 7
     fba:	60 e0       	ldi	r22, 0x00	; 0
     fbc:	70 e0       	ldi	r23, 0x00	; 0
     fbe:	45 e5       	ldi	r20, 0x55	; 85
     fc0:	50 e0       	ldi	r21, 0x00	; 0
     fc2:	20 e0       	ldi	r18, 0x00	; 0
     fc4:	30 e0       	ldi	r19, 0x00	; 0
     fc6:	02 e0       	ldi	r16, 0x02	; 2
     fc8:	0e 94 29 08 	call	0x1052	; 0x1052 <xTaskGenericCreate>
	
	// Start FreeRTOS
	vTaskStartScheduler();
     fcc:	0e 94 85 09 	call	0x130a	; 0x130a <vTaskStartScheduler>
	
     fd0:	80 e0       	ldi	r24, 0x00	; 0
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	0f 91       	pop	r16
     fd6:	ff 90       	pop	r15
     fd8:	ef 90       	pop	r14
     fda:	df 90       	pop	r13
     fdc:	cf 90       	pop	r12
     fde:	bf 90       	pop	r11
     fe0:	af 90       	pop	r10
     fe2:	08 95       	ret

00000fe4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
     fe4:	cf 93       	push	r28
     fe6:	df 93       	push	r29
     fe8:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     fea:	e0 91 fc 02 	lds	r30, 0x02FC
     fee:	f0 91 fd 02 	lds	r31, 0x02FD
     ff2:	93 83       	std	Z+3, r25	; 0x03
     ff4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     ff6:	80 91 04 03 	lds	r24, 0x0304
     ffa:	90 91 05 03 	lds	r25, 0x0305
     ffe:	c8 17       	cp	r28, r24
    1000:	d9 07       	cpc	r29, r25
    1002:	68 f4       	brcc	.+26     	; 0x101e <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1004:	80 91 08 03 	lds	r24, 0x0308
    1008:	90 91 09 03 	lds	r25, 0x0309
    100c:	60 91 fc 02 	lds	r22, 0x02FC
    1010:	70 91 fd 02 	lds	r23, 0x02FD
    1014:	6e 5f       	subi	r22, 0xFE	; 254
    1016:	7f 4f       	sbci	r23, 0xFF	; 255
    1018:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>
    101c:	17 c0       	rjmp	.+46     	; 0x104c <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    101e:	80 91 0a 03 	lds	r24, 0x030A
    1022:	90 91 0b 03 	lds	r25, 0x030B
    1026:	60 91 fc 02 	lds	r22, 0x02FC
    102a:	70 91 fd 02 	lds	r23, 0x02FD
    102e:	6e 5f       	subi	r22, 0xFE	; 254
    1030:	7f 4f       	sbci	r23, 0xFF	; 255
    1032:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1036:	80 91 65 00 	lds	r24, 0x0065
    103a:	90 91 66 00 	lds	r25, 0x0066
    103e:	c8 17       	cp	r28, r24
    1040:	d9 07       	cpc	r29, r25
    1042:	20 f4       	brcc	.+8      	; 0x104c <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1044:	d0 93 66 00 	sts	0x0066, r29
    1048:	c0 93 65 00 	sts	0x0065, r28
		}
	}
}
    104c:	df 91       	pop	r29
    104e:	cf 91       	pop	r28
    1050:	08 95       	ret

00001052 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1052:	4f 92       	push	r4
    1054:	5f 92       	push	r5
    1056:	6f 92       	push	r6
    1058:	7f 92       	push	r7
    105a:	8f 92       	push	r8
    105c:	9f 92       	push	r9
    105e:	bf 92       	push	r11
    1060:	cf 92       	push	r12
    1062:	df 92       	push	r13
    1064:	ef 92       	push	r14
    1066:	ff 92       	push	r15
    1068:	0f 93       	push	r16
    106a:	1f 93       	push	r17
    106c:	cf 93       	push	r28
    106e:	df 93       	push	r29
    1070:	2c 01       	movw	r4, r24
    1072:	4b 01       	movw	r8, r22
    1074:	ea 01       	movw	r28, r20
    1076:	39 01       	movw	r6, r18
    1078:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    107a:	81 e2       	ldi	r24, 0x21	; 33
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    1082:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1084:	00 97       	sbiw	r24, 0x00	; 0
    1086:	09 f4       	brne	.+2      	; 0x108a <xTaskGenericCreate+0x38>
    1088:	db c0       	rjmp	.+438    	; 0x1240 <xTaskGenericCreate+0x1ee>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    108a:	c1 14       	cp	r12, r1
    108c:	d1 04       	cpc	r13, r1
    108e:	09 f0       	breq	.+2      	; 0x1092 <xTaskGenericCreate+0x40>
    1090:	ec c0       	rjmp	.+472    	; 0x126a <xTaskGenericCreate+0x218>
    1092:	ce 01       	movw	r24, r28
    1094:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    1098:	6c 01       	movw	r12, r24
    109a:	f8 01       	movw	r30, r16
    109c:	90 8f       	std	Z+24, r25	; 0x18
    109e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    10a0:	00 97       	sbiw	r24, 0x00	; 0
    10a2:	29 f4       	brne	.+10     	; 0x10ae <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    10a4:	c8 01       	movw	r24, r16
    10a6:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    10aa:	8f ef       	ldi	r24, 0xFF	; 255
    10ac:	ce c0       	rjmp	.+412    	; 0x124a <xTaskGenericCreate+0x1f8>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    10ae:	c6 01       	movw	r24, r12
    10b0:	65 ea       	ldi	r22, 0xA5	; 165
    10b2:	70 e0       	ldi	r23, 0x00	; 0
    10b4:	ae 01       	movw	r20, r28
    10b6:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    10ba:	9e 01       	movw	r18, r28
    10bc:	21 50       	subi	r18, 0x01	; 1
    10be:	30 40       	sbci	r19, 0x00	; 0
    10c0:	f8 01       	movw	r30, r16
    10c2:	87 89       	ldd	r24, Z+23	; 0x17
    10c4:	90 8d       	ldd	r25, Z+24	; 0x18
    10c6:	6c 01       	movw	r12, r24
    10c8:	c2 0e       	add	r12, r18
    10ca:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    10cc:	c8 01       	movw	r24, r16
    10ce:	49 96       	adiw	r24, 0x19	; 25
    10d0:	b4 01       	movw	r22, r8
    10d2:	48 e0       	ldi	r20, 0x08	; 8
    10d4:	50 e0       	ldi	r21, 0x00	; 0
    10d6:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    10da:	f8 01       	movw	r30, r16
    10dc:	10 a2       	lds	r17, 0x90
    10de:	cb 2d       	mov	r28, r11
    10e0:	f2 e0       	ldi	r31, 0x02	; 2
    10e2:	fb 15       	cp	r31, r11
    10e4:	08 f4       	brcc	.+2      	; 0x10e8 <xTaskGenericCreate+0x96>
    10e6:	c2 e0       	ldi	r28, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    10e8:	f8 01       	movw	r30, r16
    10ea:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    10ec:	88 24       	eor	r8, r8
    10ee:	99 24       	eor	r9, r9
    10f0:	68 94       	set
    10f2:	81 f8       	bld	r8, 1
    10f4:	80 0e       	add	r8, r16
    10f6:	91 1e       	adc	r9, r17
    10f8:	c4 01       	movw	r24, r8
    10fa:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    10fe:	c8 01       	movw	r24, r16
    1100:	0c 96       	adiw	r24, 0x0c	; 12
    1102:	0e 94 b4 02 	call	0x568	; 0x568 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1106:	f8 01       	movw	r30, r16
    1108:	11 87       	std	Z+9, r17	; 0x09
    110a:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    110c:	83 e0       	ldi	r24, 0x03	; 3
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	8c 1b       	sub	r24, r28
    1112:	91 09       	sbc	r25, r1
    1114:	95 87       	std	Z+13, r25	; 0x0d
    1116:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1118:	13 8b       	std	Z+19, r17	; 0x13
    111a:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    111c:	c6 01       	movw	r24, r12
    111e:	b2 01       	movw	r22, r4
    1120:	a3 01       	movw	r20, r6
    1122:	0e 94 44 03 	call	0x688	; 0x688 <pxPortInitialiseStack>
    1126:	f8 01       	movw	r30, r16
    1128:	91 83       	std	Z+1, r25	; 0x01
    112a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    112c:	e1 14       	cp	r14, r1
    112e:	f1 04       	cpc	r15, r1
    1130:	19 f0       	breq	.+6      	; 0x1138 <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1132:	f7 01       	movw	r30, r14
    1134:	11 83       	std	Z+1, r17	; 0x01
    1136:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1138:	0f b6       	in	r0, 0x3f	; 63
    113a:	f8 94       	cli
    113c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    113e:	80 91 06 03 	lds	r24, 0x0306
    1142:	8f 5f       	subi	r24, 0xFF	; 255
    1144:	80 93 06 03 	sts	0x0306, r24
			if( pxCurrentTCB == NULL )
    1148:	80 91 fc 02 	lds	r24, 0x02FC
    114c:	90 91 fd 02 	lds	r25, 0x02FD
    1150:	00 97       	sbiw	r24, 0x00	; 0
    1152:	a1 f5       	brne	.+104    	; 0x11bc <xTaskGenericCreate+0x16a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1154:	10 93 fd 02 	sts	0x02FD, r17
    1158:	00 93 fc 02 	sts	0x02FC, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    115c:	80 91 06 03 	lds	r24, 0x0306
    1160:	81 30       	cpi	r24, 0x01	; 1
    1162:	d9 f5       	brne	.+118    	; 0x11da <xTaskGenericCreate+0x188>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1164:	ce e0       	ldi	r28, 0x0E	; 14
    1166:	d3 e0       	ldi	r29, 0x03	; 3
    1168:	ce 01       	movw	r24, r28
    116a:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
    116e:	ce 01       	movw	r24, r28
    1170:	09 96       	adiw	r24, 0x09	; 9
    1172:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
    1176:	ce 01       	movw	r24, r28
    1178:	42 96       	adiw	r24, 0x12	; 18
    117a:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    117e:	c9 e2       	ldi	r28, 0x29	; 41
    1180:	d3 e0       	ldi	r29, 0x03	; 3
    1182:	ce 01       	movw	r24, r28
    1184:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1188:	0f 2e       	mov	r0, r31
    118a:	f2 e3       	ldi	r31, 0x32	; 50
    118c:	ef 2e       	mov	r14, r31
    118e:	f3 e0       	ldi	r31, 0x03	; 3
    1190:	ff 2e       	mov	r15, r31
    1192:	f0 2d       	mov	r31, r0
    1194:	c7 01       	movw	r24, r14
    1196:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    119a:	8b e3       	ldi	r24, 0x3B	; 59
    119c:	93 e0       	ldi	r25, 0x03	; 3
    119e:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    11a2:	84 e4       	ldi	r24, 0x44	; 68
    11a4:	93 e0       	ldi	r25, 0x03	; 3
    11a6:	0e 94 a6 02 	call	0x54c	; 0x54c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    11aa:	d0 93 0b 03 	sts	0x030B, r29
    11ae:	c0 93 0a 03 	sts	0x030A, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    11b2:	f0 92 09 03 	sts	0x0309, r15
    11b6:	e0 92 08 03 	sts	0x0308, r14
    11ba:	0f c0       	rjmp	.+30     	; 0x11da <xTaskGenericCreate+0x188>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    11bc:	80 91 02 03 	lds	r24, 0x0302
    11c0:	88 23       	and	r24, r24
    11c2:	59 f4       	brne	.+22     	; 0x11da <xTaskGenericCreate+0x188>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    11c4:	e0 91 fc 02 	lds	r30, 0x02FC
    11c8:	f0 91 fd 02 	lds	r31, 0x02FD
    11cc:	86 89       	ldd	r24, Z+22	; 0x16
    11ce:	b8 16       	cp	r11, r24
    11d0:	20 f0       	brcs	.+8      	; 0x11da <xTaskGenericCreate+0x188>
					{
						pxCurrentTCB = pxNewTCB;
    11d2:	10 93 fd 02 	sts	0x02FD, r17
    11d6:	00 93 fc 02 	sts	0x02FC, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    11da:	f8 01       	movw	r30, r16
    11dc:	86 89       	ldd	r24, Z+22	; 0x16
    11de:	90 91 0c 03 	lds	r25, 0x030C
    11e2:	98 17       	cp	r25, r24
    11e4:	10 f4       	brcc	.+4      	; 0x11ea <xTaskGenericCreate+0x198>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    11e6:	80 93 0c 03 	sts	0x030C, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    11ea:	90 91 0d 03 	lds	r25, 0x030D
    11ee:	9f 5f       	subi	r25, 0xFF	; 255
    11f0:	90 93 0d 03 	sts	0x030D, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    11f4:	90 91 03 03 	lds	r25, 0x0303
    11f8:	98 17       	cp	r25, r24
    11fa:	10 f4       	brcc	.+4      	; 0x1200 <xTaskGenericCreate+0x1ae>
    11fc:	80 93 03 03 	sts	0x0303, r24
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	9c 01       	movw	r18, r24
    1204:	22 0f       	add	r18, r18
    1206:	33 1f       	adc	r19, r19
    1208:	22 0f       	add	r18, r18
    120a:	33 1f       	adc	r19, r19
    120c:	22 0f       	add	r18, r18
    120e:	33 1f       	adc	r19, r19
    1210:	82 0f       	add	r24, r18
    1212:	93 1f       	adc	r25, r19
    1214:	82 5f       	subi	r24, 0xF2	; 242
    1216:	9c 4f       	sbci	r25, 0xFC	; 252
    1218:	b4 01       	movw	r22, r8
    121a:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1222:	80 91 02 03 	lds	r24, 0x0302
    1226:	88 23       	and	r24, r24
    1228:	69 f0       	breq	.+26     	; 0x1244 <xTaskGenericCreate+0x1f2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    122a:	e0 91 fc 02 	lds	r30, 0x02FC
    122e:	f0 91 fd 02 	lds	r31, 0x02FD
    1232:	86 89       	ldd	r24, Z+22	; 0x16
    1234:	8b 15       	cp	r24, r11
    1236:	40 f4       	brcc	.+16     	; 0x1248 <xTaskGenericCreate+0x1f6>
			{
				portYIELD_WITHIN_API();
    1238:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	05 c0       	rjmp	.+10     	; 0x124a <xTaskGenericCreate+0x1f8>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1240:	8f ef       	ldi	r24, 0xFF	; 255
    1242:	03 c0       	rjmp	.+6      	; 0x124a <xTaskGenericCreate+0x1f8>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1244:	81 e0       	ldi	r24, 0x01	; 1
    1246:	01 c0       	rjmp	.+2      	; 0x124a <xTaskGenericCreate+0x1f8>
    1248:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    124a:	df 91       	pop	r29
    124c:	cf 91       	pop	r28
    124e:	1f 91       	pop	r17
    1250:	0f 91       	pop	r16
    1252:	ff 90       	pop	r15
    1254:	ef 90       	pop	r14
    1256:	df 90       	pop	r13
    1258:	cf 90       	pop	r12
    125a:	bf 90       	pop	r11
    125c:	9f 90       	pop	r9
    125e:	8f 90       	pop	r8
    1260:	7f 90       	pop	r7
    1262:	6f 90       	pop	r6
    1264:	5f 90       	pop	r5
    1266:	4f 90       	pop	r4
    1268:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    126a:	fc 01       	movw	r30, r24
    126c:	d0 8e       	std	Z+24, r13	; 0x18
    126e:	c7 8a       	std	Z+23, r12	; 0x17
    1270:	1e cf       	rjmp	.-452    	; 0x10ae <xTaskGenericCreate+0x5c>

00001272 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1272:	ef 92       	push	r14
    1274:	ff 92       	push	r15
    1276:	0f 93       	push	r16
    1278:	1f 93       	push	r17
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	f8 94       	cli
    1284:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1286:	80 91 fc 02 	lds	r24, 0x02FC
    128a:	90 91 fd 02 	lds	r25, 0x02FD
    128e:	e8 16       	cp	r14, r24
    1290:	f9 06       	cpc	r15, r25
    1292:	21 f0       	breq	.+8      	; 0x129c <vTaskDelete+0x2a>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1294:	e1 14       	cp	r14, r1
    1296:	f1 04       	cpc	r15, r1
    1298:	41 f4       	brne	.+16     	; 0x12aa <vTaskDelete+0x38>
    129a:	02 c0       	rjmp	.+4      	; 0x12a0 <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    129c:	ee 24       	eor	r14, r14
    129e:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    12a0:	c0 91 fc 02 	lds	r28, 0x02FC
    12a4:	d0 91 fd 02 	lds	r29, 0x02FD
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <vTaskDelete+0x3a>
    12aa:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    12ac:	8e 01       	movw	r16, r28
    12ae:	0e 5f       	subi	r16, 0xFE	; 254
    12b0:	1f 4f       	sbci	r17, 0xFF	; 255
    12b2:	c8 01       	movw	r24, r16
    12b4:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    12b8:	8c 89       	ldd	r24, Y+20	; 0x14
    12ba:	9d 89       	ldd	r25, Y+21	; 0x15
    12bc:	00 97       	sbiw	r24, 0x00	; 0
    12be:	21 f0       	breq	.+8      	; 0x12c8 <vTaskDelete+0x56>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    12c0:	ce 01       	movw	r24, r28
    12c2:	0c 96       	adiw	r24, 0x0c	; 12
    12c4:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    12c8:	84 e4       	ldi	r24, 0x44	; 68
    12ca:	93 e0       	ldi	r25, 0x03	; 3
    12cc:	b8 01       	movw	r22, r16
    12ce:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    12d2:	80 91 07 03 	lds	r24, 0x0307
    12d6:	8f 5f       	subi	r24, 0xFF	; 255
    12d8:	80 93 07 03 	sts	0x0307, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    12dc:	80 91 0d 03 	lds	r24, 0x030D
    12e0:	8f 5f       	subi	r24, 0xFF	; 255
    12e2:	80 93 0d 03 	sts	0x030D, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    12e6:	0f 90       	pop	r0
    12e8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    12ea:	80 91 02 03 	lds	r24, 0x0302
    12ee:	88 23       	and	r24, r24
    12f0:	29 f0       	breq	.+10     	; 0x12fc <vTaskDelete+0x8a>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    12f2:	e1 14       	cp	r14, r1
    12f4:	f1 04       	cpc	r15, r1
    12f6:	11 f4       	brne	.+4      	; 0x12fc <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    12f8:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
			}
		}
	}
    12fc:	df 91       	pop	r29
    12fe:	cf 91       	pop	r28
    1300:	1f 91       	pop	r17
    1302:	0f 91       	pop	r16
    1304:	ff 90       	pop	r15
    1306:	ef 90       	pop	r14
    1308:	08 95       	ret

0000130a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    130a:	af 92       	push	r10
    130c:	bf 92       	push	r11
    130e:	cf 92       	push	r12
    1310:	df 92       	push	r13
    1312:	ef 92       	push	r14
    1314:	ff 92       	push	r15
    1316:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1318:	84 e2       	ldi	r24, 0x24	; 36
    131a:	9b e0       	ldi	r25, 0x0B	; 11
    131c:	60 e6       	ldi	r22, 0x60	; 96
    131e:	70 e0       	ldi	r23, 0x00	; 0
    1320:	45 e5       	ldi	r20, 0x55	; 85
    1322:	50 e0       	ldi	r21, 0x00	; 0
    1324:	20 e0       	ldi	r18, 0x00	; 0
    1326:	30 e0       	ldi	r19, 0x00	; 0
    1328:	00 e0       	ldi	r16, 0x00	; 0
    132a:	ee 24       	eor	r14, r14
    132c:	ff 24       	eor	r15, r15
    132e:	cc 24       	eor	r12, r12
    1330:	dd 24       	eor	r13, r13
    1332:	aa 24       	eor	r10, r10
    1334:	bb 24       	eor	r11, r11
    1336:	0e 94 29 08 	call	0x1052	; 0x1052 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	49 f4       	brne	.+18     	; 0x1350 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    133e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1340:	80 93 02 03 	sts	0x0302, r24
		xTickCount = ( portTickType ) 0U;
    1344:	10 92 05 03 	sts	0x0305, r1
    1348:	10 92 04 03 	sts	0x0304, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    134c:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1350:	0f 91       	pop	r16
    1352:	ff 90       	pop	r15
    1354:	ef 90       	pop	r14
    1356:	df 90       	pop	r13
    1358:	cf 90       	pop	r12
    135a:	bf 90       	pop	r11
    135c:	af 90       	pop	r10
    135e:	08 95       	ret

00001360 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1360:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1362:	10 92 02 03 	sts	0x0302, r1
	vPortEndScheduler();
    1366:	0e 94 09 04 	call	0x812	; 0x812 <vPortEndScheduler>
}
    136a:	08 95       	ret

0000136c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    136c:	80 91 01 03 	lds	r24, 0x0301
    1370:	8f 5f       	subi	r24, 0xFF	; 255
    1372:	80 93 01 03 	sts	0x0301, r24
}
    1376:	08 95       	ret

00001378 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1378:	0f b6       	in	r0, 0x3f	; 63
    137a:	f8 94       	cli
    137c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    137e:	80 91 04 03 	lds	r24, 0x0304
    1382:	90 91 05 03 	lds	r25, 0x0305
	}
	taskEXIT_CRITICAL();
    1386:	0f 90       	pop	r0
    1388:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    138a:	08 95       	ret

0000138c <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    138c:	80 91 04 03 	lds	r24, 0x0304
    1390:	90 91 05 03 	lds	r25, 0x0305
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1394:	08 95       	ret

00001396 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1396:	80 91 06 03 	lds	r24, 0x0306
}
    139a:	08 95       	ret

0000139c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    13a4:	80 91 01 03 	lds	r24, 0x0301
    13a8:	88 23       	and	r24, r24
    13aa:	09 f0       	breq	.+2      	; 0x13ae <vTaskIncrementTick+0x12>
    13ac:	b3 c0       	rjmp	.+358    	; 0x1514 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    13ae:	80 91 04 03 	lds	r24, 0x0304
    13b2:	90 91 05 03 	lds	r25, 0x0305
    13b6:	01 96       	adiw	r24, 0x01	; 1
    13b8:	90 93 05 03 	sts	0x0305, r25
    13bc:	80 93 04 03 	sts	0x0304, r24
		if( xTickCount == ( portTickType ) 0U )
    13c0:	80 91 04 03 	lds	r24, 0x0304
    13c4:	90 91 05 03 	lds	r25, 0x0305
    13c8:	00 97       	sbiw	r24, 0x00	; 0
    13ca:	99 f5       	brne	.+102    	; 0x1432 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    13cc:	80 91 0a 03 	lds	r24, 0x030A
    13d0:	90 91 0b 03 	lds	r25, 0x030B
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    13d4:	20 91 08 03 	lds	r18, 0x0308
    13d8:	30 91 09 03 	lds	r19, 0x0309
    13dc:	30 93 0b 03 	sts	0x030B, r19
    13e0:	20 93 0a 03 	sts	0x030A, r18
			pxOverflowDelayedTaskList = pxTemp;
    13e4:	90 93 09 03 	sts	0x0309, r25
    13e8:	80 93 08 03 	sts	0x0308, r24
			xNumOfOverflows++;
    13ec:	80 91 fe 02 	lds	r24, 0x02FE
    13f0:	8f 5f       	subi	r24, 0xFF	; 255
    13f2:	80 93 fe 02 	sts	0x02FE, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    13f6:	e0 91 0a 03 	lds	r30, 0x030A
    13fa:	f0 91 0b 03 	lds	r31, 0x030B
    13fe:	80 81       	ld	r24, Z
    1400:	88 23       	and	r24, r24
    1402:	39 f4       	brne	.+14     	; 0x1412 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1404:	8f ef       	ldi	r24, 0xFF	; 255
    1406:	9f ef       	ldi	r25, 0xFF	; 255
    1408:	90 93 66 00 	sts	0x0066, r25
    140c:	80 93 65 00 	sts	0x0065, r24
    1410:	10 c0       	rjmp	.+32     	; 0x1432 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1412:	e0 91 0a 03 	lds	r30, 0x030A
    1416:	f0 91 0b 03 	lds	r31, 0x030B
    141a:	05 80       	ldd	r0, Z+5	; 0x05
    141c:	f6 81       	ldd	r31, Z+6	; 0x06
    141e:	e0 2d       	mov	r30, r0
    1420:	06 80       	ldd	r0, Z+6	; 0x06
    1422:	f7 81       	ldd	r31, Z+7	; 0x07
    1424:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1426:	82 81       	ldd	r24, Z+2	; 0x02
    1428:	93 81       	ldd	r25, Z+3	; 0x03
    142a:	90 93 66 00 	sts	0x0066, r25
    142e:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1432:	20 91 04 03 	lds	r18, 0x0304
    1436:	30 91 05 03 	lds	r19, 0x0305
    143a:	80 91 65 00 	lds	r24, 0x0065
    143e:	90 91 66 00 	lds	r25, 0x0066
    1442:	28 17       	cp	r18, r24
    1444:	39 07       	cpc	r19, r25
    1446:	08 f4       	brcc	.+2      	; 0x144a <vTaskIncrementTick+0xae>
    1448:	6a c0       	rjmp	.+212    	; 0x151e <vTaskIncrementTick+0x182>
    144a:	e0 91 0a 03 	lds	r30, 0x030A
    144e:	f0 91 0b 03 	lds	r31, 0x030B
    1452:	80 81       	ld	r24, Z
    1454:	88 23       	and	r24, r24
    1456:	99 f0       	breq	.+38     	; 0x147e <vTaskIncrementTick+0xe2>
    1458:	e0 91 0a 03 	lds	r30, 0x030A
    145c:	f0 91 0b 03 	lds	r31, 0x030B
    1460:	05 80       	ldd	r0, Z+5	; 0x05
    1462:	f6 81       	ldd	r31, Z+6	; 0x06
    1464:	e0 2d       	mov	r30, r0
    1466:	c6 81       	ldd	r28, Z+6	; 0x06
    1468:	d7 81       	ldd	r29, Z+7	; 0x07
    146a:	8a 81       	ldd	r24, Y+2	; 0x02
    146c:	9b 81       	ldd	r25, Y+3	; 0x03
    146e:	20 91 04 03 	lds	r18, 0x0304
    1472:	30 91 05 03 	lds	r19, 0x0305
    1476:	28 17       	cp	r18, r24
    1478:	39 07       	cpc	r19, r25
    147a:	f8 f4       	brcc	.+62     	; 0x14ba <vTaskIncrementTick+0x11e>
    147c:	19 c0       	rjmp	.+50     	; 0x14b0 <vTaskIncrementTick+0x114>
    147e:	8f ef       	ldi	r24, 0xFF	; 255
    1480:	9f ef       	ldi	r25, 0xFF	; 255
    1482:	90 93 66 00 	sts	0x0066, r25
    1486:	80 93 65 00 	sts	0x0065, r24
    148a:	49 c0       	rjmp	.+146    	; 0x151e <vTaskIncrementTick+0x182>
    148c:	e0 91 0a 03 	lds	r30, 0x030A
    1490:	f0 91 0b 03 	lds	r31, 0x030B
    1494:	05 80       	ldd	r0, Z+5	; 0x05
    1496:	f6 81       	ldd	r31, Z+6	; 0x06
    1498:	e0 2d       	mov	r30, r0
    149a:	c6 81       	ldd	r28, Z+6	; 0x06
    149c:	d7 81       	ldd	r29, Z+7	; 0x07
    149e:	8a 81       	ldd	r24, Y+2	; 0x02
    14a0:	9b 81       	ldd	r25, Y+3	; 0x03
    14a2:	20 91 04 03 	lds	r18, 0x0304
    14a6:	30 91 05 03 	lds	r19, 0x0305
    14aa:	28 17       	cp	r18, r24
    14ac:	39 07       	cpc	r19, r25
    14ae:	28 f4       	brcc	.+10     	; 0x14ba <vTaskIncrementTick+0x11e>
    14b0:	90 93 66 00 	sts	0x0066, r25
    14b4:	80 93 65 00 	sts	0x0065, r24
    14b8:	32 c0       	rjmp	.+100    	; 0x151e <vTaskIncrementTick+0x182>
    14ba:	8e 01       	movw	r16, r28
    14bc:	0e 5f       	subi	r16, 0xFE	; 254
    14be:	1f 4f       	sbci	r17, 0xFF	; 255
    14c0:	c8 01       	movw	r24, r16
    14c2:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
    14c6:	8c 89       	ldd	r24, Y+20	; 0x14
    14c8:	9d 89       	ldd	r25, Y+21	; 0x15
    14ca:	00 97       	sbiw	r24, 0x00	; 0
    14cc:	21 f0       	breq	.+8      	; 0x14d6 <vTaskIncrementTick+0x13a>
    14ce:	ce 01       	movw	r24, r28
    14d0:	0c 96       	adiw	r24, 0x0c	; 12
    14d2:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
    14d6:	8e 89       	ldd	r24, Y+22	; 0x16
    14d8:	90 91 03 03 	lds	r25, 0x0303
    14dc:	98 17       	cp	r25, r24
    14de:	10 f4       	brcc	.+4      	; 0x14e4 <vTaskIncrementTick+0x148>
    14e0:	80 93 03 03 	sts	0x0303, r24
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	9c 01       	movw	r18, r24
    14e8:	22 0f       	add	r18, r18
    14ea:	33 1f       	adc	r19, r19
    14ec:	22 0f       	add	r18, r18
    14ee:	33 1f       	adc	r19, r19
    14f0:	22 0f       	add	r18, r18
    14f2:	33 1f       	adc	r19, r19
    14f4:	82 0f       	add	r24, r18
    14f6:	93 1f       	adc	r25, r19
    14f8:	82 5f       	subi	r24, 0xF2	; 242
    14fa:	9c 4f       	sbci	r25, 0xFC	; 252
    14fc:	b8 01       	movw	r22, r16
    14fe:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
    1502:	e0 91 0a 03 	lds	r30, 0x030A
    1506:	f0 91 0b 03 	lds	r31, 0x030B
    150a:	80 81       	ld	r24, Z
    150c:	88 23       	and	r24, r24
    150e:	09 f0       	breq	.+2      	; 0x1512 <vTaskIncrementTick+0x176>
    1510:	bd cf       	rjmp	.-134    	; 0x148c <vTaskIncrementTick+0xf0>
    1512:	b5 cf       	rjmp	.-150    	; 0x147e <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    1514:	80 91 00 03 	lds	r24, 0x0300
    1518:	8f 5f       	subi	r24, 0xFF	; 255
    151a:	80 93 00 03 	sts	0x0300, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    151e:	df 91       	pop	r29
    1520:	cf 91       	pop	r28
    1522:	1f 91       	pop	r17
    1524:	0f 91       	pop	r16
    1526:	08 95       	ret

00001528 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1528:	af 92       	push	r10
    152a:	bf 92       	push	r11
    152c:	cf 92       	push	r12
    152e:	df 92       	push	r13
    1530:	ef 92       	push	r14
    1532:	ff 92       	push	r15
    1534:	0f 93       	push	r16
    1536:	1f 93       	push	r17
    1538:	cf 93       	push	r28
    153a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	f8 94       	cli
    1540:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1542:	80 91 01 03 	lds	r24, 0x0301
    1546:	81 50       	subi	r24, 0x01	; 1
    1548:	80 93 01 03 	sts	0x0301, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    154c:	80 91 01 03 	lds	r24, 0x0301
    1550:	88 23       	and	r24, r24
    1552:	09 f0       	breq	.+2      	; 0x1556 <xTaskResumeAll+0x2e>
    1554:	69 c0       	rjmp	.+210    	; 0x1628 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1556:	80 91 06 03 	lds	r24, 0x0306
    155a:	88 23       	and	r24, r24
    155c:	81 f5       	brne	.+96     	; 0x15be <xTaskResumeAll+0x96>
    155e:	67 c0       	rjmp	.+206    	; 0x162e <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1560:	d6 01       	movw	r26, r12
    1562:	ed 91       	ld	r30, X+
    1564:	fc 91       	ld	r31, X
    1566:	c6 81       	ldd	r28, Z+6	; 0x06
    1568:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    156a:	ce 01       	movw	r24, r28
    156c:	0c 96       	adiw	r24, 0x0c	; 12
    156e:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1572:	8e 01       	movw	r16, r28
    1574:	0e 5f       	subi	r16, 0xFE	; 254
    1576:	1f 4f       	sbci	r17, 0xFF	; 255
    1578:	c8 01       	movw	r24, r16
    157a:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    157e:	8e 89       	ldd	r24, Y+22	; 0x16
    1580:	90 91 03 03 	lds	r25, 0x0303
    1584:	98 17       	cp	r25, r24
    1586:	10 f4       	brcc	.+4      	; 0x158c <xTaskResumeAll+0x64>
    1588:	80 93 03 03 	sts	0x0303, r24
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	9c 01       	movw	r18, r24
    1590:	22 0f       	add	r18, r18
    1592:	33 1f       	adc	r19, r19
    1594:	22 0f       	add	r18, r18
    1596:	33 1f       	adc	r19, r19
    1598:	22 0f       	add	r18, r18
    159a:	33 1f       	adc	r19, r19
    159c:	82 0f       	add	r24, r18
    159e:	93 1f       	adc	r25, r19
    15a0:	82 5f       	subi	r24, 0xF2	; 242
    15a2:	9c 4f       	sbci	r25, 0xFC	; 252
    15a4:	b8 01       	movw	r22, r16
    15a6:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    15aa:	e0 91 fc 02 	lds	r30, 0x02FC
    15ae:	f0 91 fd 02 	lds	r31, 0x02FD
    15b2:	9e 89       	ldd	r25, Y+22	; 0x16
    15b4:	86 89       	ldd	r24, Z+22	; 0x16
    15b6:	98 17       	cp	r25, r24
    15b8:	88 f0       	brcs	.+34     	; 0x15dc <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    15ba:	ba 2c       	mov	r11, r10
    15bc:	0f c0       	rjmp	.+30     	; 0x15dc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    15be:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    15c0:	0f 2e       	mov	r0, r31
    15c2:	fb e3       	ldi	r31, 0x3B	; 59
    15c4:	ef 2e       	mov	r14, r31
    15c6:	f3 e0       	ldi	r31, 0x03	; 3
    15c8:	ff 2e       	mov	r15, r31
    15ca:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    15cc:	0f 2e       	mov	r0, r31
    15ce:	f0 e4       	ldi	r31, 0x40	; 64
    15d0:	cf 2e       	mov	r12, r31
    15d2:	f3 e0       	ldi	r31, 0x03	; 3
    15d4:	df 2e       	mov	r13, r31
    15d6:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    15d8:	aa 24       	eor	r10, r10
    15da:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    15dc:	f7 01       	movw	r30, r14
    15de:	80 81       	ld	r24, Z
    15e0:	88 23       	and	r24, r24
    15e2:	09 f0       	breq	.+2      	; 0x15e6 <xTaskResumeAll+0xbe>
    15e4:	bd cf       	rjmp	.-134    	; 0x1560 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    15e6:	80 91 00 03 	lds	r24, 0x0300
    15ea:	88 23       	and	r24, r24
    15ec:	81 f0       	breq	.+32     	; 0x160e <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    15ee:	80 91 00 03 	lds	r24, 0x0300
    15f2:	88 23       	and	r24, r24
    15f4:	99 f0       	breq	.+38     	; 0x161c <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    15f6:	0e 94 ce 09 	call	0x139c	; 0x139c <vTaskIncrementTick>
						--uxMissedTicks;
    15fa:	80 91 00 03 	lds	r24, 0x0300
    15fe:	81 50       	subi	r24, 0x01	; 1
    1600:	80 93 00 03 	sts	0x0300, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1604:	80 91 00 03 	lds	r24, 0x0300
    1608:	88 23       	and	r24, r24
    160a:	a9 f7       	brne	.-22     	; 0x15f6 <xTaskResumeAll+0xce>
    160c:	07 c0       	rjmp	.+14     	; 0x161c <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    160e:	f1 e0       	ldi	r31, 0x01	; 1
    1610:	bf 16       	cp	r11, r31
    1612:	21 f0       	breq	.+8      	; 0x161c <xTaskResumeAll+0xf4>
    1614:	80 91 ff 02 	lds	r24, 0x02FF
    1618:	81 30       	cpi	r24, 0x01	; 1
    161a:	41 f4       	brne	.+16     	; 0x162c <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    161c:	10 92 ff 02 	sts	0x02FF, r1
					portYIELD_WITHIN_API();
    1620:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	03 c0       	rjmp	.+6      	; 0x162e <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1628:	80 e0       	ldi	r24, 0x00	; 0
    162a:	01 c0       	rjmp	.+2      	; 0x162e <xTaskResumeAll+0x106>
    162c:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    162e:	0f 90       	pop	r0
    1630:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	1f 91       	pop	r17
    1638:	0f 91       	pop	r16
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	df 90       	pop	r13
    1640:	cf 90       	pop	r12
    1642:	bf 90       	pop	r11
    1644:	af 90       	pop	r10
    1646:	08 95       	ret

00001648 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1648:	04 e4       	ldi	r16, 0x44	; 68
    164a:	13 e0       	ldi	r17, 0x03	; 3
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    164c:	0f 2e       	mov	r0, r31
    164e:	f9 e4       	ldi	r31, 0x49	; 73
    1650:	ef 2e       	mov	r14, r31
    1652:	f3 e0       	ldi	r31, 0x03	; 3
    1654:	ff 2e       	mov	r15, r31
    1656:	f0 2d       	mov	r31, r0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1658:	80 91 07 03 	lds	r24, 0x0307
    165c:	88 23       	and	r24, r24
    165e:	e1 f3       	breq	.-8      	; 0x1658 <prvIdleTask+0x10>
		{
			vTaskSuspendAll();
    1660:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1664:	d8 01       	movw	r26, r16
    1666:	cc 91       	ld	r28, X
			xTaskResumeAll();
    1668:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    166c:	cc 23       	and	r28, r28
    166e:	a1 f3       	breq	.-24     	; 0x1658 <prvIdleTask+0x10>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1670:	0f b6       	in	r0, 0x3f	; 63
    1672:	f8 94       	cli
    1674:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1676:	d7 01       	movw	r26, r14
    1678:	ed 91       	ld	r30, X+
    167a:	fc 91       	ld	r31, X
    167c:	c6 81       	ldd	r28, Z+6	; 0x06
    167e:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1680:	ce 01       	movw	r24, r28
    1682:	02 96       	adiw	r24, 0x02	; 2
    1684:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
					--uxCurrentNumberOfTasks;
    1688:	80 91 06 03 	lds	r24, 0x0306
    168c:	81 50       	subi	r24, 0x01	; 1
    168e:	80 93 06 03 	sts	0x0306, r24
					--uxTasksDeleted;
    1692:	80 91 07 03 	lds	r24, 0x0307
    1696:	81 50       	subi	r24, 0x01	; 1
    1698:	80 93 07 03 	sts	0x0307, r24
				}
				taskEXIT_CRITICAL();
    169c:	0f 90       	pop	r0
    169e:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    16a0:	8f 89       	ldd	r24, Y+23	; 0x17
    16a2:	98 8d       	ldd	r25, Y+24	; 0x18
    16a4:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
		vPortFree( pxTCB );
    16a8:	ce 01       	movw	r24, r28
    16aa:	0e 94 97 02 	call	0x52e	; 0x52e <vPortFree>
    16ae:	d4 cf       	rjmp	.-88     	; 0x1658 <prvIdleTask+0x10>

000016b0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    16b0:	cf 93       	push	r28
    16b2:	df 93       	push	r29
    16b4:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    16b6:	00 97       	sbiw	r24, 0x00	; 0
    16b8:	b1 f0       	breq	.+44     	; 0x16e6 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    16ba:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    16be:	80 91 04 03 	lds	r24, 0x0304
    16c2:	90 91 05 03 	lds	r25, 0x0305
    16c6:	c8 0f       	add	r28, r24
    16c8:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    16ca:	80 91 fc 02 	lds	r24, 0x02FC
    16ce:	90 91 fd 02 	lds	r25, 0x02FD
    16d2:	02 96       	adiw	r24, 0x02	; 2
    16d4:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    16d8:	ce 01       	movw	r24, r28
    16da:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    16de:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    16e2:	88 23       	and	r24, r24
    16e4:	11 f4       	brne	.+4      	; 0x16ea <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    16e6:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
		}
	}
    16ea:	df 91       	pop	r29
    16ec:	cf 91       	pop	r28
    16ee:	08 95       	ret

000016f0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    16f0:	0f 93       	push	r16
    16f2:	1f 93       	push	r17
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	8c 01       	movw	r16, r24
    16fa:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    16fc:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1700:	f8 01       	movw	r30, r16
    1702:	80 81       	ld	r24, Z
    1704:	91 81       	ldd	r25, Z+1	; 0x01
    1706:	c8 0f       	add	r28, r24
    1708:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    170a:	20 91 04 03 	lds	r18, 0x0304
    170e:	30 91 05 03 	lds	r19, 0x0305
    1712:	28 17       	cp	r18, r24
    1714:	39 07       	cpc	r19, r25
    1716:	68 f4       	brcc	.+26     	; 0x1732 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1718:	c8 17       	cp	r28, r24
    171a:	d9 07       	cpc	r29, r25
    171c:	50 f5       	brcc	.+84     	; 0x1772 <vTaskDelayUntil+0x82>
    171e:	80 91 04 03 	lds	r24, 0x0304
    1722:	90 91 05 03 	lds	r25, 0x0305
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1726:	d1 83       	std	Z+1, r29	; 0x01
    1728:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    172a:	8c 17       	cp	r24, r28
    172c:	9d 07       	cpc	r25, r29
    172e:	b0 f4       	brcc	.+44     	; 0x175c <vTaskDelayUntil+0x6c>
    1730:	0b c0       	rjmp	.+22     	; 0x1748 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1732:	c8 17       	cp	r28, r24
    1734:	d9 07       	cpc	r29, r25
    1736:	c8 f0       	brcs	.+50     	; 0x176a <vTaskDelayUntil+0x7a>
    1738:	80 91 04 03 	lds	r24, 0x0304
    173c:	90 91 05 03 	lds	r25, 0x0305
    1740:	8c 17       	cp	r24, r28
    1742:	9d 07       	cpc	r25, r29
    1744:	90 f0       	brcs	.+36     	; 0x176a <vTaskDelayUntil+0x7a>
    1746:	15 c0       	rjmp	.+42     	; 0x1772 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1748:	80 91 fc 02 	lds	r24, 0x02FC
    174c:	90 91 fd 02 	lds	r25, 0x02FD
    1750:	02 96       	adiw	r24, 0x02	; 2
    1752:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1756:	ce 01       	movw	r24, r28
    1758:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    175c:	0e 94 94 0a 	call	0x1528	; 0x1528 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1760:	88 23       	and	r24, r24
    1762:	59 f4       	brne	.+22     	; 0x177a <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1764:	0e 94 0a 04 	call	0x814	; 0x814 <vPortYield>
    1768:	08 c0       	rjmp	.+16     	; 0x177a <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    176a:	f8 01       	movw	r30, r16
    176c:	d1 83       	std	Z+1, r29	; 0x01
    176e:	c0 83       	st	Z, r28
    1770:	eb cf       	rjmp	.-42     	; 0x1748 <vTaskDelayUntil+0x58>
    1772:	f8 01       	movw	r30, r16
    1774:	d1 83       	std	Z+1, r29	; 0x01
    1776:	c0 83       	st	Z, r28
    1778:	f1 cf       	rjmp	.-30     	; 0x175c <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    177a:	df 91       	pop	r29
    177c:	cf 91       	pop	r28
    177e:	1f 91       	pop	r17
    1780:	0f 91       	pop	r16
    1782:	08 95       	ret

00001784 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1784:	80 91 01 03 	lds	r24, 0x0301
    1788:	88 23       	and	r24, r24
    178a:	99 f4       	brne	.+38     	; 0x17b2 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    178c:	80 91 03 03 	lds	r24, 0x0303
    1790:	90 e0       	ldi	r25, 0x00	; 0
    1792:	fc 01       	movw	r30, r24
    1794:	ee 0f       	add	r30, r30
    1796:	ff 1f       	adc	r31, r31
    1798:	ee 0f       	add	r30, r30
    179a:	ff 1f       	adc	r31, r31
    179c:	ee 0f       	add	r30, r30
    179e:	ff 1f       	adc	r31, r31
    17a0:	8e 0f       	add	r24, r30
    17a2:	9f 1f       	adc	r25, r31
    17a4:	fc 01       	movw	r30, r24
    17a6:	e2 5f       	subi	r30, 0xF2	; 242
    17a8:	fc 4f       	sbci	r31, 0xFC	; 252
    17aa:	80 81       	ld	r24, Z
    17ac:	88 23       	and	r24, r24
    17ae:	29 f0       	breq	.+10     	; 0x17ba <vTaskSwitchContext+0x36>
    17b0:	1b c0       	rjmp	.+54     	; 0x17e8 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	80 93 ff 02 	sts	0x02FF, r24
    17b8:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    17ba:	80 91 03 03 	lds	r24, 0x0303
    17be:	81 50       	subi	r24, 0x01	; 1
    17c0:	80 93 03 03 	sts	0x0303, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    17c4:	80 91 03 03 	lds	r24, 0x0303
    17c8:	90 e0       	ldi	r25, 0x00	; 0
    17ca:	fc 01       	movw	r30, r24
    17cc:	ee 0f       	add	r30, r30
    17ce:	ff 1f       	adc	r31, r31
    17d0:	ee 0f       	add	r30, r30
    17d2:	ff 1f       	adc	r31, r31
    17d4:	ee 0f       	add	r30, r30
    17d6:	ff 1f       	adc	r31, r31
    17d8:	8e 0f       	add	r24, r30
    17da:	9f 1f       	adc	r25, r31
    17dc:	fc 01       	movw	r30, r24
    17de:	e2 5f       	subi	r30, 0xF2	; 242
    17e0:	fc 4f       	sbci	r31, 0xFC	; 252
    17e2:	80 81       	ld	r24, Z
    17e4:	88 23       	and	r24, r24
    17e6:	49 f3       	breq	.-46     	; 0x17ba <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    17e8:	80 91 03 03 	lds	r24, 0x0303
    17ec:	90 e0       	ldi	r25, 0x00	; 0
    17ee:	fc 01       	movw	r30, r24
    17f0:	ee 0f       	add	r30, r30
    17f2:	ff 1f       	adc	r31, r31
    17f4:	ee 0f       	add	r30, r30
    17f6:	ff 1f       	adc	r31, r31
    17f8:	ee 0f       	add	r30, r30
    17fa:	ff 1f       	adc	r31, r31
    17fc:	e8 0f       	add	r30, r24
    17fe:	f9 1f       	adc	r31, r25
    1800:	e2 5f       	subi	r30, 0xF2	; 242
    1802:	fc 4f       	sbci	r31, 0xFC	; 252
    1804:	a1 81       	ldd	r26, Z+1	; 0x01
    1806:	b2 81       	ldd	r27, Z+2	; 0x02
    1808:	12 96       	adiw	r26, 0x02	; 2
    180a:	0d 90       	ld	r0, X+
    180c:	bc 91       	ld	r27, X
    180e:	a0 2d       	mov	r26, r0
    1810:	b2 83       	std	Z+2, r27	; 0x02
    1812:	a1 83       	std	Z+1, r26	; 0x01
    1814:	cf 01       	movw	r24, r30
    1816:	03 96       	adiw	r24, 0x03	; 3
    1818:	a8 17       	cp	r26, r24
    181a:	b9 07       	cpc	r27, r25
    181c:	31 f4       	brne	.+12     	; 0x182a <vTaskSwitchContext+0xa6>
    181e:	12 96       	adiw	r26, 0x02	; 2
    1820:	8d 91       	ld	r24, X+
    1822:	9c 91       	ld	r25, X
    1824:	13 97       	sbiw	r26, 0x03	; 3
    1826:	92 83       	std	Z+2, r25	; 0x02
    1828:	81 83       	std	Z+1, r24	; 0x01
    182a:	01 80       	ldd	r0, Z+1	; 0x01
    182c:	f2 81       	ldd	r31, Z+2	; 0x02
    182e:	e0 2d       	mov	r30, r0
    1830:	86 81       	ldd	r24, Z+6	; 0x06
    1832:	97 81       	ldd	r25, Z+7	; 0x07
    1834:	90 93 fd 02 	sts	0x02FD, r25
    1838:	80 93 fc 02 	sts	0x02FC, r24
    183c:	08 95       	ret

0000183e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    183e:	cf 93       	push	r28
    1840:	df 93       	push	r29
    1842:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1844:	60 91 fc 02 	lds	r22, 0x02FC
    1848:	70 91 fd 02 	lds	r23, 0x02FD
    184c:	64 5f       	subi	r22, 0xF4	; 244
    184e:	7f 4f       	sbci	r23, 0xFF	; 255
    1850:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1854:	80 91 fc 02 	lds	r24, 0x02FC
    1858:	90 91 fd 02 	lds	r25, 0x02FD
    185c:	02 96       	adiw	r24, 0x02	; 2
    185e:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1862:	80 91 04 03 	lds	r24, 0x0304
    1866:	90 91 05 03 	lds	r25, 0x0305
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    186a:	8c 0f       	add	r24, r28
    186c:	9d 1f       	adc	r25, r29
    186e:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1872:	df 91       	pop	r29
    1874:	cf 91       	pop	r28
    1876:	08 95       	ret

00001878 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1878:	0f 93       	push	r16
    187a:	1f 93       	push	r17
    187c:	cf 93       	push	r28
    187e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1880:	dc 01       	movw	r26, r24
    1882:	15 96       	adiw	r26, 0x05	; 5
    1884:	ed 91       	ld	r30, X+
    1886:	fc 91       	ld	r31, X
    1888:	16 97       	sbiw	r26, 0x06	; 6
    188a:	06 81       	ldd	r16, Z+6	; 0x06
    188c:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    188e:	e8 01       	movw	r28, r16
    1890:	2c 96       	adiw	r28, 0x0c	; 12
    1892:	ce 01       	movw	r24, r28
    1894:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1898:	80 91 01 03 	lds	r24, 0x0301
    189c:	88 23       	and	r24, r24
    189e:	e9 f4       	brne	.+58     	; 0x18da <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    18a0:	e8 01       	movw	r28, r16
    18a2:	22 96       	adiw	r28, 0x02	; 2
    18a4:	ce 01       	movw	r24, r28
    18a6:	0e 94 1e 03 	call	0x63c	; 0x63c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    18aa:	f8 01       	movw	r30, r16
    18ac:	86 89       	ldd	r24, Z+22	; 0x16
    18ae:	90 91 03 03 	lds	r25, 0x0303
    18b2:	98 17       	cp	r25, r24
    18b4:	10 f4       	brcc	.+4      	; 0x18ba <xTaskRemoveFromEventList+0x42>
    18b6:	80 93 03 03 	sts	0x0303, r24
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	9c 01       	movw	r18, r24
    18be:	22 0f       	add	r18, r18
    18c0:	33 1f       	adc	r19, r19
    18c2:	22 0f       	add	r18, r18
    18c4:	33 1f       	adc	r19, r19
    18c6:	22 0f       	add	r18, r18
    18c8:	33 1f       	adc	r19, r19
    18ca:	82 0f       	add	r24, r18
    18cc:	93 1f       	adc	r25, r19
    18ce:	82 5f       	subi	r24, 0xF2	; 242
    18d0:	9c 4f       	sbci	r25, 0xFC	; 252
    18d2:	be 01       	movw	r22, r28
    18d4:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
    18d8:	05 c0       	rjmp	.+10     	; 0x18e4 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    18da:	8b e3       	ldi	r24, 0x3B	; 59
    18dc:	93 e0       	ldi	r25, 0x03	; 3
    18de:	be 01       	movw	r22, r28
    18e0:	0e 94 b8 02 	call	0x570	; 0x570 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    18e4:	e0 91 fc 02 	lds	r30, 0x02FC
    18e8:	f0 91 fd 02 	lds	r31, 0x02FD
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	d8 01       	movw	r26, r16
    18f0:	56 96       	adiw	r26, 0x16	; 22
    18f2:	2c 91       	ld	r18, X
    18f4:	56 97       	sbiw	r26, 0x16	; 22
    18f6:	96 89       	ldd	r25, Z+22	; 0x16
    18f8:	29 17       	cp	r18, r25
    18fa:	08 f4       	brcc	.+2      	; 0x18fe <xTaskRemoveFromEventList+0x86>
    18fc:	80 e0       	ldi	r24, 0x00	; 0
}
    18fe:	df 91       	pop	r29
    1900:	cf 91       	pop	r28
    1902:	1f 91       	pop	r17
    1904:	0f 91       	pop	r16
    1906:	08 95       	ret

00001908 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1908:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    190a:	80 91 fe 02 	lds	r24, 0x02FE
    190e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1910:	80 91 04 03 	lds	r24, 0x0304
    1914:	90 91 05 03 	lds	r25, 0x0305
    1918:	92 83       	std	Z+2, r25	; 0x02
    191a:	81 83       	std	Z+1, r24	; 0x01
}
    191c:	08 95       	ret

0000191e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    191e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1920:	0f b6       	in	r0, 0x3f	; 63
    1922:	f8 94       	cli
    1924:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1926:	80 91 fe 02 	lds	r24, 0x02FE
    192a:	90 81       	ld	r25, Z
    192c:	98 17       	cp	r25, r24
    192e:	49 f0       	breq	.+18     	; 0x1942 <xTaskCheckForTimeOut+0x24>
    1930:	80 91 04 03 	lds	r24, 0x0304
    1934:	90 91 05 03 	lds	r25, 0x0305
    1938:	21 81       	ldd	r18, Z+1	; 0x01
    193a:	32 81       	ldd	r19, Z+2	; 0x02
    193c:	82 17       	cp	r24, r18
    193e:	93 07       	cpc	r25, r19
    1940:	f0 f4       	brcc	.+60     	; 0x197e <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1942:	80 91 04 03 	lds	r24, 0x0304
    1946:	90 91 05 03 	lds	r25, 0x0305
    194a:	21 81       	ldd	r18, Z+1	; 0x01
    194c:	32 81       	ldd	r19, Z+2	; 0x02
    194e:	db 01       	movw	r26, r22
    1950:	4d 91       	ld	r20, X+
    1952:	5c 91       	ld	r21, X
    1954:	11 97       	sbiw	r26, 0x01	; 1
    1956:	82 1b       	sub	r24, r18
    1958:	93 0b       	sbc	r25, r19
    195a:	84 17       	cp	r24, r20
    195c:	95 07       	cpc	r25, r21
    195e:	88 f4       	brcc	.+34     	; 0x1982 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1960:	80 91 04 03 	lds	r24, 0x0304
    1964:	90 91 05 03 	lds	r25, 0x0305
    1968:	28 1b       	sub	r18, r24
    196a:	39 0b       	sbc	r19, r25
    196c:	24 0f       	add	r18, r20
    196e:	35 1f       	adc	r19, r21
    1970:	2d 93       	st	X+, r18
    1972:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1974:	cf 01       	movw	r24, r30
    1976:	0e 94 84 0c 	call	0x1908	; 0x1908 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	03 c0       	rjmp	.+6      	; 0x1984 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	01 c0       	rjmp	.+2      	; 0x1984 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1982:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1984:	0f 90       	pop	r0
    1986:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1988:	08 95       	ret

0000198a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	80 93 ff 02 	sts	0x02FF, r24
}
    1990:	08 95       	ret

00001992 <memcpy>:
    1992:	fb 01       	movw	r30, r22
    1994:	dc 01       	movw	r26, r24
    1996:	02 c0       	rjmp	.+4      	; 0x199c <memcpy+0xa>
    1998:	01 90       	ld	r0, Z+
    199a:	0d 92       	st	X+, r0
    199c:	41 50       	subi	r20, 0x01	; 1
    199e:	50 40       	sbci	r21, 0x00	; 0
    19a0:	d8 f7       	brcc	.-10     	; 0x1998 <memcpy+0x6>
    19a2:	08 95       	ret

000019a4 <memset>:
    19a4:	dc 01       	movw	r26, r24
    19a6:	01 c0       	rjmp	.+2      	; 0x19aa <memset+0x6>
    19a8:	6d 93       	st	X+, r22
    19aa:	41 50       	subi	r20, 0x01	; 1
    19ac:	50 40       	sbci	r21, 0x00	; 0
    19ae:	e0 f7       	brcc	.-8      	; 0x19a8 <memset+0x4>
    19b0:	08 95       	ret

000019b2 <strncpy>:
    19b2:	fb 01       	movw	r30, r22
    19b4:	dc 01       	movw	r26, r24
    19b6:	41 50       	subi	r20, 0x01	; 1
    19b8:	50 40       	sbci	r21, 0x00	; 0
    19ba:	48 f0       	brcs	.+18     	; 0x19ce <strncpy+0x1c>
    19bc:	01 90       	ld	r0, Z+
    19be:	0d 92       	st	X+, r0
    19c0:	00 20       	and	r0, r0
    19c2:	c9 f7       	brne	.-14     	; 0x19b6 <strncpy+0x4>
    19c4:	01 c0       	rjmp	.+2      	; 0x19c8 <strncpy+0x16>
    19c6:	1d 92       	st	X+, r1
    19c8:	41 50       	subi	r20, 0x01	; 1
    19ca:	50 40       	sbci	r21, 0x00	; 0
    19cc:	e0 f7       	brcc	.-8      	; 0x19c6 <strncpy+0x14>
    19ce:	08 95       	ret

000019d0 <_exit>:
    19d0:	f8 94       	cli

000019d2 <__stop_program>:
    19d2:	ff cf       	rjmp	.-2      	; 0x19d2 <__stop_program>
